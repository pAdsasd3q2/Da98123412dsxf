-- Credits To The Original Devs @xz, @goof
getgenv().Config = {
	Invite = "Sync.wtf - Ready 2 die 0.0.4c",
	Version = "0.6",
}

getgenv().luaguardvars = {
	DiscordName = "4stud on discord",
}

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Yield1111/Ui-lib/refs/heads/main/Ui%20lib"))()

library:init() -- Initalizes Library Do Not Delete This

local Window = library.NewWindow({
	title = "r2d shit",
	size = UDim2.new(0, 525, 0, 650)
})

local tabs = {
    Tab1 = Window:AddTab("Main"),
	Settings = library:CreateSettingsTab(Window),
}

-- 1 = Set Section Box To The Left
-- 2 = Set Section Box To The Right

local sections = {
	Section1 = tabs.Tab1:AddSection("Exploits", 1),
    Section2 = tabs.Tab1:AddSection("Farm", 2),

}


sections.Section1:AddButton({
    enabled = true,
    text = "Reset",
    flag = "Button_1",
    tooltip = "Resets u",
    confirm = true,
    risky = false,
    callback = function()     

local ohNumber1 = math.huge
local ohString2 = "RemoteDeath"

game:GetService("ReplicatedStorage").Events.SelfDamage:FireServer(ohNumber1, ohString2)
    end
})

_G.AutoReset = true

function AutoReset()
    while _G.AutoReset == true do
        local ohNumber1 = math.huge
        local ohString2 = "RemoteDeath"
        
        game:GetService("ReplicatedStorage").Events.SelfDamage:FireServer(ohNumber1, ohString2)
        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Auto reset (ticket farm)",
    flag = "Toggle_1",
    callback = function(v)
        _G.AutoReset  = v
        AutoReset()
    end
})







_G.SpamChat = true

function SpamChat()
    while _G.SpamChat == true do
        local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.882353, 0.294118, 0)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end







local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0, 0.678431, 0.054902)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.776471, 0, 0.831373)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)




local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.541176, 0.541176, 0.541176)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.890196, 0.890196, 0)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)





local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.94902, 0.560784, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)




local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end


-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.188235, 0.498039, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(1, 1, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)


local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(1, 0.615686, 0)
local ohString4 = "Exp"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)
wait(0)
    end
end


sections.Section1:AddToggle({
    text = "Spam party",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamChat  = v
        library:SendNotification("Spam party", 5, Color3.new(255, 0, 0))
        SpamChat()
    end
})


_G.Snowball = true

function Snowball()
    while _G.Snowball == true do
        local function getClosestModelPosition(currentPosition)
            local closestModel = nil
            local closestDistance = math.huge  -- Start with a large number for comparison
            
            -- Iterate through all survivors in workspace.Characters.Survivors
            for _, model in pairs(game.Workspace.Characters.Survivors:GetChildren()) do
                if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
                    local modelPosition = model.HumanoidRootPart.Position
                    local distance = (modelPosition - currentPosition).Magnitude
                    
                    -- Check if this model is closer than the previous closest one
                    if distance < closestDistance then
                        closestDistance = distance
                        closestModel = model
                    end
                end
            end
            
            -- Return the position of the closest model or the original position if no model was found
            return closestModel and closestModel.HumanoidRootPart.Position or currentPosition
        end
        
        -- Original position (can be replaced with the variable you want to change)
        local ohVector31 = Vector3.new(0.4920186996459961, 0.05185193940997124, -0.869038999080658)
        
        -- Get the nearest model's position
        local closestPosition = getClosestModelPosition(ohVector31)
        
        -- Fire the event with the updated position
        game:GetService("ReplicatedStorage").Events.ThrowBall:FireServer(closestPosition)
        wait(0)
    end
end





sections.Section1:AddToggle({
    text = "Snowball auto shoot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Snowball  = v
        Snowball()
    end
})





_G.KingStreet = true

function KingStreet()
    while _G.KingStreet == true do
-- Get the Players service
local Players = game:GetService("Players")

-- Find the "wheel" part in the NoRay workspace
local workspaceNoRay = game.Workspace.NoRay
local wheelPart = workspaceNoRay:FindFirstChild("wheel")

-- Check if the "wheel" part exists
if wheelPart then
    -- Get the local player (assuming this is running on the client)
    local player = Players.LocalPlayer

    -- Teleport to the "wheel" part
    player.Character:SetPrimaryPartCFrame(wheelPart.CFrame)
    
    -- Wait for 0.5 seconds
    wait(0.5)
    
    -- Find the "wheel" parts in the truck's wheels
    local truck = game.Workspace.Map.Truck.KingstreetTruck
    local wheels = truck:WaitForChild("Wheels")

    -- Loop through all parts named "wheel" and teleport to each one
    for _, part in pairs(wheels:GetChildren()) do
        if part.Name == "wheel" then
            player.Character:SetPrimaryPartCFrame(part.CFrame)
            wait(0.5)  -- Wait for 0.5 seconds before teleporting to the next one
        end
    end
    
    -- Teleport to the truck's position after the loop
    player.Character:SetPrimaryPartCFrame(truck.CFrame)
else
    warn("No wheel part found in NoRay workspace.")
end

        wait(1)
    end
end





sections.Section1:AddToggle({
    text = "Auto complete Kingstreet campaign",
    flag = "Toggle_1",
    callback = function(v)
        _G.KingStreet  = v
        KingStreet()
    end
})






_G.TicketFarm = true

function TicketFarm()
    local lastTicket = nil -- Store the last ticket part
    local repeatCount = 0 -- Count consecutive visits to the same part

    while _G.TicketFarm == true do
        local workspace = game:GetService("Workspace") -- Get the Workspace service
        local players = game:GetService("Players") -- Get the Players service
        local noRayFolder = workspace:WaitForChild("NoRay") -- Find the NoRay folder
        local ticketPart = noRayFolder:FindFirstChild("Ticket") -- Try to find the part named "Ticket"

        -- Skip the ticket if visited more than 5 times consecutively
        if ticketPart and ticketPart == lastTicket then
            repeatCount += 1
            if repeatCount > 5 then
                wait(0.1) -- Slight delay before checking again
                continue -- Skip this iteration
            end
        else
            -- Reset the repeat count and update the last ticket
            repeatCount = 0
            lastTicket = ticketPart
        end

        local targetPosition

        if ticketPart then
            -- If "Ticket" is found, use its position to teleport
            targetPosition = ticketPart.Position
        else
            -- If "Ticket" is not found, teleport to the sky position (0, 1000, 0)
            targetPosition = Vector3.new(0, 1000, 0)
        end

        -- Teleport the character (or specific model) to the target position using Lerp
        local character = players.LocalPlayer.Character
        if character then
            -- Ensure the character has a HumanoidRootPart
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Set the Lerp parameters
                local startPosition = humanoidRootPart.Position
                local steps = 5 -- Number of interpolation steps (higher value for smoother movement)
                local duration = 0.2 -- Total time to complete the teleport (in seconds)
                local stepDuration = duration / steps -- Time per step

                -- Add a BodyVelocity to set velocity to 0
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.Velocity = Vector3.zero
                bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000) -- High force to stabilize
                bodyVelocity.Parent = humanoidRootPart

                -- Disable collision during teleportation
                humanoidRootPart.CanCollide = false

                -- Smooth Lerp movement with wobble effect
                for i = 1, steps do
                    -- Calculate the interpolation progress
                    local progress = i / steps
                    -- Add wobble effect
                    local wobbleOffset = Vector3.new(
                        math.random(-5, 5) * 0.1, -- Small random x offset
                        math.random(-5, 5) * 0.1, -- Small random y offset
                        math.random(-5, 5) * 0.1  -- Small random z offset
                    )
                    local wobblePosition = targetPosition + wobbleOffset

                    -- Move the HumanoidRootPart incrementally
                    humanoidRootPart.CFrame = CFrame.new(startPosition:Lerp(wobblePosition, progress))

                    wait(stepDuration) -- Wait for the next step
                end

                -- Ensure the final position is exactly the target position
                humanoidRootPart.CFrame = CFrame.new(targetPosition)

                -- Cleanup: Remove BodyVelocity and re-enable collision
                bodyVelocity:Destroy()
                humanoidRootPart.CanCollide = true
            end
        end

        wait(0.1) -- Add slight delay for smoother wobbling
    end
end

sections.Section2:AddToggle({
    text = "Ticket farm",
    flag = "Toggle_1",
    callback = function(v)
        _G.TicketFarm = v
        if v then
            TicketFarm()
        end
    end
})






_G.ModDetector = true

function ModDetector()
    while _G.ModDetector == true do
-- List of usernames to detect
local blacklistedNames = {
    "c4rpye", "scott1333", "sagecrisi_s", "JackLighters", "alum_i", 
    "Masterdude180", "drinkyz", "IDunhill", "Dr_Greedster", "Tekrinn", 
    "TheeOfficalOG", "ur_lucky", "Synween", "mrvriie"
}

-- Get the Players service
local players = game:GetService("Players")

-- Function to check for blacklisted players
local function checkForBlacklistedPlayers()
    for _, player in ipairs(players:GetPlayers()) do
        if table.find(blacklistedNames, player.Name) then
            -- Kick the local player if a blacklisted name is found
            players.LocalPlayer:Kick("Mod detected: " .. player.Name)
            break
        end
    end
end

-- Connect to the PlayerAdded event to check new players joining
players.PlayerAdded:Connect(function(newPlayer)
    if table.find(blacklistedNames, newPlayer.Name) then
        players.LocalPlayer:Kick("Mod detected: " .. newPlayer.Name)
    end
end)

-- Initial check for players already in the game
checkForBlacklistedPlayers()

        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Mod Detector",
    flag = "Toggle_1",
    callback = function(v)
        _G.ModDetector  = v
        ModDetector()
    end
})







_G.PunchSound = true

function PunchSound()
    while _G.PunchSound == true do
        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Punch"
local ohNumber2 = 1

game:GetService("ReplicatedStorage").Events.Survivor.SoundFire:FireServer(ohString1, ohNumber2)

local ohString1 = "Punch"
local ohNumber2 = 3

game:GetService("ReplicatedStorage").Events.Survivor.SoundFire:FireServer(ohString1, ohNumber2)

        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Punch spam sound",
    flag = "Toggle_1",
    callback = function(v)
        _G.PunchSound  = v
        PunchSound()
    end
})


_G.VoteNo = true

function VoteNo()
    while _G.VoteNo == true do
        local ohNumber1 = -1

        game:GetService("ReplicatedStorage").Events.Vote:FireServer(ohNumber1)
        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Vote No to maps",
    flag = "Toggle_1",
    callback = function(v)
        _G.VoteNo  = v
        VoteNo()
    end
})


_G.GiftTp = true







function GiftTp()
    while _G.GiftTp == true do
-- List of target names
local targetNames = {
    "Aqua Gift",
    "Common Gift",
    "Gift of Fortune",
    "Gift of Kindness",
    "Gift of Life",
    "Golden Gift",
    "Legendary Gift",
    "Rare Gift"
}

-- Function to check if the player is inside workspace.Characters.Survivors
local function isPlayerInSurvivors()
    -- Get the Players service
    local players = game:GetService("Players")
    local player = players.LocalPlayer
    
    -- Check if the player's character exists
    if not player or not player.Character then
        return false
    end

    -- Check if the player's character is inside workspace.Characters.Survivors
    return workspace.Characters:FindFirstChild("Survivors") and workspace.Characters.Survivors:FindFirstChild(player.Character.Name)
end

-- Function to check if the player owns a specific gift
local function doesPlayerOwnGift(giftName)
    local player = game:GetService("Players").LocalPlayer
    local inventory = player:FindFirstChild("INVENTORY")
    
    -- Ensure the inventory and Secondary exist
    if not inventory or not inventory:FindFirstChild("Secondary") then
        return false
    end

    -- Check if the specific gift exists in the Secondary inventory
    for _, item in pairs(inventory.Secondary:GetChildren()) do
        if item.Name == giftName then
            return true -- Player already owns this specific gift
        end
    end
    
    return false -- Gift not found in inventory
end

-- Function to teleport the player to a gift if in the correct area, and return them back
local function teleportToGift()
    -- Get the Players service
    local players = game:GetService("Players")
    local player = players.LocalPlayer

    -- Check if the player is inside workspace.Characters.Survivors
    if not isPlayerInSurvivors() then
        -- Send notification if the player is not inside Survivors
        print("Not survivor")
        return
    end

    -- Store the player's current position
    local initialPosition = player.Character.HumanoidRootPart.CFrame

    -- Flag to check if a gift was found
    local giftFound = false

    -- Iterate through each object in workspace.Map
    for _, object in pairs(workspace.Map:GetChildren()) do
        -- Check if the object is a model or part and if its name matches any of the target names
        for _, name in ipairs(targetNames) do
            if object.Name == name then
                -- Check if the player already owns this specific gift
                if doesPlayerOwnGift(name) then
                    library:SendNotification("You already own: " .. name, 5, Color3.new(255, 255, 0)) -- Yellow for owned gift
                    return -- Stop processing if the gift is owned
                end

                -- If the player does not own the gift, teleport to its location
                player.Character.HumanoidRootPart.CFrame = object.CFrame
                -- Notify that the player was teleported
                library:SendNotification("Teleported to: " .. name, 5, Color3.new(0, 255, 0)) -- Green for success
                giftFound = true
                -- Simulate the jump (apply force to the Humanoid)
                local humanoid = player.Character:WaitForChild("Humanoid")
                wait(0.5) -- Wait for the jump to be initiated (adjust as necessary)
                -- Teleport the player back to their initial position
                player.Character.HumanoidRootPart.CFrame = initialPosition
                -- Notify that the player is back at their original location
                library:SendNotification("Teleported back", 5, Color3.new(0, 0, 255)) -- Blue for teleport back
                return -- Stop the loop after teleporting
            end
        end
    end

    -- If no gift was found, send a notification
    if not giftFound then
        library:SendNotification("No Gift Found", 5, Color3.new(255, 0, 0)) -- Red for error
    end
end

-- Call the function to teleport to the first gift found
teleportToGift()

        wait(1)
    end
end



sections.Section2:AddToggle({
    text = "Teleport to gifts",
    flag = "Toggle_1",
    callback = function(v)
        _G.GiftTp  = v
        GiftTp()
    end
})

sections.Section2:AddSeparator({
    enabled = true,
    text = "Kill aura"
})

_G.MeleeKillAura = true

function MeleeKillAura()
    while _G.MeleeKillAura == true do
        local zombies = workspace.Characters.Zombies
        local survivors = workspace.Characters.Survivors
        local player = game:GetService("Players").LocalPlayer
        
        -- Iterate through each tool in the player's backpack
        for _, tool in pairs(player.Backpack:GetChildren()) do
            -- Check if the item is a Tool and has a 'Slash' event
            if tool:IsA("Tool") and tool:FindFirstChild("Slash") then
                -- Iterate through each zombie in workspace.Characters.Zombies
                for _, zombie in pairs(zombies:GetChildren()) do
                    -- Ensure the zombie has a Head and Humanoid
                    if zombie:FindFirstChild("Head") and zombie:FindFirstChild("Humanoid") then
                        local head = zombie.Head
                        local humanoid = zombie.Humanoid
                        
                        -- Prepare the table with necessary info for the Slash
                        local ohTable2 = {
                            ["HeadShot"] = true,
                            ["Humanoid"] = humanoid,
                            ["Combo"] = 1,
                            ["Weapon"] = tool,
                            ["NoStruggle"] = true
                        }
        
                        -- Fire the Slash event for each zombie
                        tool.Slash:FireServer(head, ohTable2)
                    end
                end
                
                -- Iterate through each survivor in workspace.Characters.Survivors
                for _, survivor in pairs(survivors:GetChildren()) do
                    -- Ensure the survivor has a Head and Humanoid
                    if survivor:FindFirstChild("Head") and survivor:FindFirstChild("Humanoid") then
                        local head = survivor.Head
                        local humanoid = survivor.Humanoid
                        
                        -- Prepare the table with necessary info for the Slash
                        local ohTable2 = {
                            ["HeadShot"] = true,
                            ["Humanoid"] = humanoid,
                            ["Combo"] = 1,
                            ["Weapon"] = tool,
                            ["NoStruggle"] = true
                        }
        
                        -- Fire the Slash event for each survivor
                        tool.Slash:FireServer(head, ohTable2)
                    end
                end
            end
        end
        
        wait(0.00001)
    end
end



sections.Section2:AddToggle({
    text = "Melee kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.MeleeKillAura  = v
        MeleeKillAura()


    end
})


_G.TpZombies = true

function TpZombies()
    while _G.TpZombies == true do
-- Get a reference to the Zombies folder in the workspace
local zombiesFolder = game.Workspace.Characters.Zombies

-- Define a fallback position in the sky
local skyPosition = Vector3.new(0, 1000, 0)  -- You can adjust the Y value to determine how high in the sky

-- Check if the Zombies folder exists and has models in it
if zombiesFolder and #zombiesFolder:GetChildren() > 0 then
    -- Get a random model from the Zombies folder
    local randomZombie = zombiesFolder:GetChildren()[math.random(1, #zombiesFolder:GetChildren())]

    -- Check if the model has a HumanoidRootPart
    local humanoidRootPart = randomZombie:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        -- Get the position of the HumanoidRootPart and add a Y offset of 15 studs
        local targetPosition = humanoidRootPart.Position + Vector3.new(0, 12.5, 0)

        -- Get the player's character
        local playerCharacter = game:GetService("Players").LocalPlayer.Character

        -- Check if the player has a HumanoidRootPart and a Humanoid
        local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
        local humanoid = playerCharacter:FindFirstChild("Humanoid")

        if humanoidRootPartPlayer and humanoid then
            -- Temporarily set the velocity of the player's HumanoidRootPart to zero
            humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)

            -- Teleport the player to the new position
            playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))
        else
            warn("Player does not have a HumanoidRootPart or Humanoid.")
        end
    else
        warn("Random zombie model does not have a HumanoidRootPart.")
    end
else
    warn("No zombies found in the Zombies folder.")

    -- If no zombies are found, teleport the player to the sky
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPartPlayer then
        -- Temporarily set the velocity to 0 to prevent fall damage
        humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)
        -- Teleport the player to the sky position
        playerCharacter:SetPrimaryPartCFrame(CFrame.new(skyPosition))
    else
        warn("Player does not have a HumanoidRootPart.")
    end
end

      wait(0.15)  
    end
    end


sections.Section2:AddToggle({
    text = "Teleport to Zombies",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpZombies = v
        TpZombies()
    end
})

_G.TpSurvivors = true

function TpSurvivors()
    while _G.TpSurvivors == true do
-- Get a reference to the Zombies folder in the workspace
local zombiesFolder = game.Workspace.Characters.Survivors

-- Define a fallback position in the sky
local skyPosition = Vector3.new(0, 1000, 0)  -- You can adjust the Y value to determine how high in the sky

-- Check if the Zombies folder exists and has models in it
if zombiesFolder and #zombiesFolder:GetChildren() > 0 then
    -- Get a random model from the Zombies folder
    local randomZombie = zombiesFolder:GetChildren()[math.random(1, #zombiesFolder:GetChildren())]

    -- Check if the model has a HumanoidRootPart
    local humanoidRootPart = randomZombie:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        -- Get the position of the HumanoidRootPart and add a Y offset of 15 studs
        local targetPosition = humanoidRootPart.Position + Vector3.new(0, 12.5, 0)

        -- Get the player's character
        local playerCharacter = game:GetService("Players").LocalPlayer.Character

        -- Check if the player has a HumanoidRootPart and a Humanoid
        local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
        local humanoid = playerCharacter:FindFirstChild("Humanoid")

        if humanoidRootPartPlayer and humanoid then
            -- Temporarily set the velocity of the player's HumanoidRootPart to zero
            humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)

            -- Teleport the player to the new position
            playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))
        else
            warn("Player does not have a HumanoidRootPart or Humanoid.")
        end
    else
        warn("Random zombie model does not have a HumanoidRootPart.")
    end
else
    warn("No zombies found in the Zombies folder.")

    -- If no zombies are found, teleport the player to the sky
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPartPlayer then
        -- Temporarily set the velocity to 0 to prevent fall damage
        humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)
        -- Teleport the player to the sky position
        playerCharacter:SetPrimaryPartCFrame(CFrame.new(skyPosition))
    else
        warn("Player does not have a HumanoidRootPart.")
    end
end


      wait(0.15)  
    end
    end


sections.Section2:AddToggle({
    text = "Teleport to Survivors",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpSurvivors = v
        TpSurvivors()
    end
})


















sections.Section1:AddSeparator({
    enabled = true,
    text = "Zombie Exploits"
})

_G.SpamBlock = true

function SpamBlock()
    while _G.SpamBlock == true do
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Yield1111/Crash/refs/heads/main/Brute"))()  
        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Spam block (Brute) Crasher/Lag",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamBlock  = v
        SpamBlock()
    end
})









_G.SpamClub = true

function SpamClub()
    while _G.SpamClub == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to wait until the character is loaded
local function waitForCharacter(player)
    while not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") do
        wait(0.1)
    end
end

-- Wait for the character to be fully loaded
waitForCharacter(LocalPlayer)

-- Save the survivor's original position
local originalCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame

-- Get all survivors in workspace
local survivors = workspace.Characters:FindFirstChild("Survivors")
if not survivors then
print("2222") 
   return
end

-- Get all characters in the survivors folder
local survivorList = {}
for _, survivor in pairs(survivors:GetChildren()) do
    if survivor:IsA("Model") and survivor:FindFirstChild("Humanoid") then
        table.insert(survivorList, survivor)
    end
end

-- If there are no survivors
if #survivorList == 0 then
print("22222") 
   return
end

-- Pick a random survivor
local randomSurvivor = survivorList[math.random(1, #survivorList)]

-- Teleport to the random survivor's position
if randomSurvivor and randomSurvivor:FindFirstChild("HumanoidRootPart") then
    LocalPlayer.Character.HumanoidRootPart.CFrame = randomSurvivor.HumanoidRootPart.CFrame
    
    -- Send a notification that you've teleported
print("222222")
    -- Fire the remote event
    local ohBoolean1 = true
    game:GetService("ReplicatedStorage").Events.Zombie.ClawAttacked:FireServer()

    -- Check the health of the survivor
    local humanoid = randomSurvivor:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid.Health <= 0 then
            -- If the target's health is 0, notify and stop further actions
print("222")            return
        else
            -- If the survivor is still alive, notify and stop after teleporting once
            print("22222")
        end
    end
end

        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Kill all (Brute) BROKEN!",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamClub  = v
        SpamClub()
    end
})


_G.Elmspam = true

function Elmspam()
    while _G.Elmspam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor has health greater than 0
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to shoot at the closest survivor
local function shootAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.ElmM1:FireServer(shootPosition)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to shoot at.")
    end
end

-- Call the function to shoot at the closest survivor
shootAtClosestSurvivor()

        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "elm auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Elmspam  = v
        Elmspam()
    end
})

_G.Beespam = true

function Beespam()
    while _G.Beespam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to fire at the closest survivor
local function fireAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        local ohString1 = "Honey"  -- You can keep this string as is if needed
        game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(ohString1, shootPosition)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to fire at.")
    end
end

-- Call the function to fire at the closest survivor
fireAtClosestSurvivor()


        
        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "bee auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Beespam  = v
        Beespam()
    end
})



_G.HiveSpam = true

function HiveSpam()
    while _G.HiveSpam == true do
        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Charge"

game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(ohString1)

wait(0.01)

local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to shoot at the closest survivor
local function shootAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shotPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(shotPosition)

        -- Optionally, print a message for debugging
        print("Shooting at: " .. closestSurvivor.Name)
    else
        print("No survivors found to shoot at.")
    end
end

-- Call the function to shoot at the closest survivor
shootAtClosestSurvivor()


        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Hive auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.HiveSpam  = v
        HiveSpam()
    end
})















_G.EdgarSpam = true

function EdgarSpam()
    while _G.EdgarSpam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to fire at the closest survivor
local function fireAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.Tongue:FireServer({["Position"] = shootPosition}, true)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to fire at.")
    end
end

-- Call the function to fire at the closest survivor
fireAtClosestSurvivor()

        
        wait(0)
        
    end
end

        




sections.Section1:AddToggle({
    text = "Edgar auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.EdgarSpam  = v
        EdgarSpam()
    end
})

sections.Section1:AddSeparator({
    enabled = true,
    text = "Visuals"
})

function FovChanger()
    local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

-- Set FOV when player respawns
player.CharacterAdded:Connect(function(character)
    -- Wait until the camera is ready
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    -- Set the desired FOV
    camera.FieldOfView = 120
end)
    wait(0.00000001)
    local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

-- Desired FOV value
local targetFOV = 120

-- Continuously set the FOV every frame using RenderStepped
game:GetService("RunService").RenderStepped:Connect(function()
    camera.FieldOfView = targetFOV
end)
wait(0.5)
end 




_G.Fov = true

function Fov()
    while _G.Fov == true do
        FovChanger()
        wait(0.00000001)
    end
end



sections.Section1:AddToggle({
    text = "Fov (Survivor)",
    flag = "Toggle_1",
    callback = function(v)
        _G.Fov  = v
        Fov()
    end
})





_G.ForcefieldWeapon = true

function ForcefieldWeapon()
    while _G.ForcefieldWeapon == true do
        local player = game:GetService("Players").LocalPlayer
local character = workspace.Characters.Survivors:FindFirstChild(player.Name)

if player:FindFirstChild("Tools") then
    for _, tool in pairs(player.Tools:GetChildren()) do
        -- Ensure the item is a tool
        if tool:IsA("Tool") then
            for _, part in pairs(tool:GetDescendants()) do
                if part:IsA("BasePart") then
                    -- Create a new Part with the ForceField material
                    local forceFieldPart = Instance.new("Part")
                    forceFieldPart.Size = part.Size
                    forceFieldPart.CFrame = part.CFrame
                    forceFieldPart.Anchored = true
                    forceFieldPart.CanCollide = false
                    forceFieldPart.Transparency = 0.5  -- Semi-transparent for the force field effect
                    forceFieldPart.Material = Enum.Material.ForceField  -- Set the material to ForceField
                    forceFieldPart.BrickColor = BrickColor.new("Bright red")  -- Red color
                    forceFieldPart.Parent = part  -- Parent it to the original part
                end
            end
        end
    end
end

        
        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Make your weapon forcefield",
    flag = "Toggle_1",
    callback = function(v)
        _G.ForcefieldWeapon  = v
        ForcefieldWeapon()
    end
})



_G.HighlightAll = true

function highlight()
    while _G.HighlightAll == true do
        local player = game.Players.LocalPlayer
        local highlightService = game:GetService("Highlight")
        
        -- Function to apply highlight to a character model
        local function highlightCharacter(character)
            -- Check if the character is not the local player's character
            if character and character.Parent and character.Parent == workspace and character:FindFirstChild("Humanoid") and character.Parent.Name ~= player.Name then
                -- Create a highlight instance
                local highlight = Instance.new("Highlight")
                highlight.Parent = character
                
                -- Apply color based on the character's folder (Survivors or Zombies)
                if workspace.Characters.Survivors:FindFirstChild(character.Name) then
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)  -- Blue for Survivors
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 0)  -- Dark Blue outline for Survivors
                elseif workspace.Characters.Zombies:FindFirstChild(character.Name) then
                    highlight.FillColor = Color3.fromRGB(255, 0, 0)  -- Red for Zombies
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 0)  -- Dark Red outline for Zombies
                end
                
                highlight.FillTransparency = 0.5 -- Transparency level
                highlight.OutlineTransparency = 0.3 -- Outline transparency
            end
        end
        
        -- Function to remove highlight from a character model
        local function removeHighlight(character)
            if character and character:FindFirstChild("Highlight") then
                character.Highlight:Destroy()
            end
        end
        
        -- Loop through Survivors and Zombies and apply highlight
        local function highlightAllCharacters()
            for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
                highlightCharacter(survivor)
            end
        
            for _, zombie in pairs(workspace.Characters.Zombies:GetChildren()) do
                highlightCharacter(zombie)
            end
        end
        
        -- Run the function to highlight all characters on script start
        highlightAllCharacters()
        
        -- Optional: Re-highlight when new characters spawn
        workspace.Characters.Survivors.ChildAdded:Connect(highlightCharacter)
        workspace.Characters.Zombies.ChildAdded:Connect(highlightCharacter)
        
        -- Optional: Remove highlight when characters are removed
        workspace.Characters.Survivors.ChildRemoved:Connect(removeHighlight)
        workspace.Characters.Zombies.ChildRemoved:Connect(removeHighlight)
        
    wait(0.5)
    


end


end


_G.HighlightAll = true

function HighlightAll()
    while _G.HighlightAll == true do
        highlight()
        wait(0.5)
    end
end



sections.Section1:AddToggle({
    text = "Highlight",
    flag = "Toggle_1",
    callback = function(v)
        _G.HighlightAll  = v
        HighlightAll()
    end
})

sections.Section1:AddSeparator({
    enabled = true,
    text = "Misc"
})




sections.Section1:AddButton({
    enabled = true,
    text = "Inf yield",
    flag = "Button_1",
    tooltip = "inf yield",
    confirm = true,
    risky = false,
    callback = function()     



loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/main/latest.lua'))()
    end
})








_G.ZombieKillAura = true

function ZombieKillAura()
    while _G.ZombieKillAura == true do
        local survivorsFolder = workspace.Characters.Survivors

        -- Loop through all the models in the Survivors folder
        for _, survivor in pairs(survivorsFolder:GetChildren()) do
            -- Check if the survivor model has the necessary parts
            local humanoid = survivor:FindFirstChild("Humanoid")
            local humanoidRootPart = survivor:FindFirstChild("HumanoidRootPart")
            
            -- Only proceed if both the Humanoid and HumanoidRootPart exist
            if humanoid and humanoidRootPart then
                -- Fire the event for each survivor
                game:GetService("ReplicatedStorage").Events.Zombie.ClawAttacked:FireServer(humanoid, nil, nil, humanoidRootPart)
            end
        end
        
        wait(0.0001)
    end
end



sections.Section2:AddToggle({
    text = "Zombie kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.ZombieKillAura  = v
        ZombieKillAura()
    end
})







library:SendNotification("Updated logs: Added Auto Complete KingStreet", 5, Color3.new(255, 0, 0))


library:SendNotification("Sync.wtf Succesfully Loaded!", 5, Color3.new(255, 0, 0))





--Window:SetOpen(true) -- Either Close Or Open Window
