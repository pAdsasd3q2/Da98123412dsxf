-- Credits To The Original Devs @xz, @goof
getgenv().Config = {
	Invite = "Sync.wtf - Ready 2 die 0.0.4c",
	Version = "0.6",
}

getgenv().luaguardvars = {
	DiscordName = "4stud on discord",
}

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Yield1111/Ui-lib/refs/heads/main/Ui%20lib%202"))()

library:init() -- Initalizes Library Do Not Delete This

local Window = library.NewWindow({
	title = "Ready 2 die 0.0.4c",
	size = UDim2.new(0, 525, 0, 650)
})

local tabs = {
    Tab1 = Window:AddTab("Main"),
	Settings = library:CreateSettingsTab(Window),
}

-- 1 = Set Section Box To The Left
-- 2 = Set Section Box To The Right

local sections = {
	Section1 = tabs.Tab1:AddSection("Exploits", 1),
    Section2 = tabs.Tab1:AddSection("Farm", 2),
}


sections.Section1:AddButton({
    enabled = true,
    text = "Reset",
    flag = "Button_1",
    tooltip = "Resets u",
    confirm = true,
    risky = false,
    callback = function()     

local ohNumber1 = math.huge
local ohString2 = "RemoteDeath"

game:GetService("ReplicatedStorage").Events.SelfDamage:FireServer(ohNumber1, ohString2)
    end
})

_G.AutoReset = true

function AutoReset()
    while _G.AutoReset == true do
        local ohNumber1 = math.huge
        local ohString2 = "RemoteDeath"
        
        game:GetService("ReplicatedStorage").Events.SelfDamage:FireServer(ohNumber1, ohString2)
        wait(2)
    end
end



sections.Section1:AddToggle({
    text = "Auto reset (ticket farm)",
    flag = "Toggle_1",
    callback = function(v)
        _G.AutoReset  = v
        AutoReset()
    end
})



_G.AntiRadiation = true

function AntiRadiation()
    while _G.AntiRadiation == true do
if workspace:FindFirstChild("Decay") then
    local decayFolder = workspace.Decay
    for _, descendant in ipairs(decayFolder:GetDescendants()) do
        if descendant.Name == "Toxic" then
            descendant:Destroy()
        end
    end
end
wait(0.01)

    end
end



sections.Section1:AddToggle({
    text = "Anti radiation",
    flag = "Toggle_1",
    callback = function(v)
        _G.AntiRadiation  = v
        AntiRadiation()
    end
})






_G.SpamChat = true

function SpamChat()
    while _G.SpamChat == true do
        local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.882353, 0.294118, 0)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end







local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0, 0.678431, 0.054902)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.776471, 0, 0.831373)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)




local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.541176, 0.541176, 0.541176)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.890196, 0.890196, 0)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)





local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.94902, 0.560784, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)




local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end


-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.188235, 0.498039, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(1, 1, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)


local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(1, 0.615686, 0)
local ohString4 = "Exp"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)
wait(0.001)
    end
end


sections.Section1:AddToggle({
    text = "Spam party",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamChat  = v
        library:SendNotification("Spam party", 5, Color3.new(255, 0, 0))
        SpamChat()
    end
})


_G.Snowball = true

function Snowball()
    while _G.Snowball == true do
        local function getClosestModelPosition(currentPosition)
            local closestModel = nil
            local closestDistance = math.huge  -- Start with a large number for comparison
            
            -- Iterate through all survivors in workspace.Characters.Survivors
            for _, model in pairs(game.Workspace.Characters.Survivors:GetChildren()) do
                if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
                    local modelPosition = model.HumanoidRootPart.Position
                    local distance = (modelPosition - currentPosition).Magnitude
                    
                    -- Check if this model is closer than the previous closest one
                    if distance < closestDistance then
                        closestDistance = distance
                        closestModel = model
                    end
                end
            end
            
            -- Return the position of the closest model or the original position if no model was found
            return closestModel and closestModel.HumanoidRootPart.Position or currentPosition
        end
        
        -- Original position (can be replaced with the variable you want to change)
        local ohVector31 = Vector3.new(0.4920186996459961, 0.05185193940997124, -0.869038999080658)
        
        -- Get the nearest model's position
        local closestPosition = getClosestModelPosition(ohVector31)
        
        -- Fire the event with the updated position
        game:GetService("ReplicatedStorage").Events.ThrowBall:FireServer(closestPosition)
        wait(0.001)
    end
end





sections.Section1:AddToggle({
    text = "Snowball auto shoot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Snowball  = v
        Snowball()
    end
})







_G.KingStreet = true

-- Function to enable noclip (if needed) for teleporting without collision issues
function enableNoclip(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

-- Function to disable noclip (return collision back to normal)
function disableNoclip(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

-- Constantly set velocity to zero to prevent fall damage
function preventFallDamage()
    while _G.KingStreet do
        local humanoidRootPart = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.Velocity = Vector3.zero
        end
        wait(0.01) -- Small delay to avoid overloading
    end
end

-- Smooth Lerp movement with wobble effect
function lerpMoveToPosition(fromPosition, toPosition, duration)
    local startTime = tick()

    while tick() - startTime < duration do
        local progress = (tick() - startTime) / duration
        local currentPosition = fromPosition:Lerp(toPosition, progress)

        -- Add wobble effect (tiny random offsets)
        local wobbleOffset = Vector3.new(
            math.random(-10, 10) * 0.2, -- Small random x offset
            math.random(-10, 10) * 0.2, -- Small random y offset
            math.random(-10, 10) * 0.2  -- Small random z offset
        )
        
        -- Apply the wobble effect to the current position
        local finalPosition = currentPosition + wobbleOffset
        game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(finalPosition)

        wait(0.05) -- Small delay between steps
    end

    -- Ensure final position is exactly the target position
    game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(toPosition)
end

-- Function to teleport the character to a random part named "wheel" in workspace.NoRay
function teleportToRandomWheel()
    local noRayFolder = workspace:WaitForChild("NoRay")
    local wheels = {}

    -- Find all parts named "wheel"
    for _, part in pairs(noRayFolder:GetChildren()) do
        if part.Name == "wheel" and part:IsA("BasePart") then
            table.insert(wheels, part)
        end
    end

    -- If there are any wheels, teleport to one at random
    if #wheels > 0 then
        local randomWheel = wheels[math.random(1, #wheels)]
        local humanoidRootPart = game:GetService("Players").LocalPlayer.Character:WaitForChild("HumanoidRootPart")

        -- Teleport to the same wheel about 5 times
        for i = 1, 5 do
            lerpMoveToPosition(humanoidRootPart.Position, randomWheel.Position, 0.05)  -- 0.05 second duration
            wait(0.01) -- Wait for 2 seconds at the wheel after each teleport
        end
    else
        print("No wheels found in workspace.NoRay!")
    end
end

-- Function to teleport to all "wheel" parts in workspace.Map.Truck.KingstreetTruck.Wheels
function teleportToAllKingStreetWheels()
    local kingStreetFolder = workspace:WaitForChild("Map"):WaitForChild("Truck"):WaitForChild("KingstreetTruck"):WaitForChild("Wheels")
    local wheels = {}

    -- Find all parts named "wheel"
    for _, part in pairs(kingStreetFolder:GetChildren()) do
        if part.Name == "wheel" and part:IsA("BasePart") then
            table.insert(wheels, part)
        end
    end

    -- Teleport to each "wheel" part with Lerp
    for _, wheel in pairs(wheels) do
        local humanoidRootPart = game:GetService("Players").LocalPlayer.Character:WaitForChild("HumanoidRootPart")

        -- Use Lerp to teleport smoothly to each "wheel" part
        lerpMoveToPosition(humanoidRootPart.Position, wheel.Position, 0.03)  -- Reduced duration to 0.1 seconds
    end
end

-- Function to start the process of teleportation and wobble
function KingStreet()
    while _G.KingStreet do
        -- Start fall damage prevention in a separate thread each loop
        spawn(preventFallDamage)

        -- First teleport to a random "wheel" in workspace.NoRay and visit it 5 times
        teleportToRandomWheel()

        -- Then teleport to all "wheel" parts in workspace.Map.Truck.KingstreetTruck.Wheels
        teleportToAllKingStreetWheels()

        -- Small delay between loops
        wait(0.05)
    end
end

-- Toggle for starting/stopping the KingStreet campaign
sections.Section1:AddToggle({
    text = "Auto complete Kingstreet campaign",
    flag = "Toggle_1",
    callback = function(v)
        _G.KingStreet = v
        if v then
            spawn(KingStreet) -- Run KingStreet in a separate thread
        end
    end
})




local backupMap = {} -- Table to store backup of Map contents



_G.TicketFarm = true

function enableNoclip(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

function disableNoclip(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

function TicketFarm()
    -- Get references to Workspace folders
    local workspace = game:GetService("Workspace")
    local charactersFolder = workspace:WaitForChild("Characters")
    local survivorsFolder = charactersFolder:WaitForChild("Survivors")
    local zombiesFolder = charactersFolder:WaitForChild("Zombies")

    -- Locate the player's character
    local localPlayerName = game:GetService("Players").LocalPlayer.Name
    local characterInSurvivors = survivorsFolder:FindFirstChild(localPlayerName)

    -- Wait until the player is in Survivors
    while not characterInSurvivors do
        print("Player not in survivors")
        characterInSurvivors = survivorsFolder:FindFirstChild(localPlayerName)
        wait(0.1)
    end

    -- Get the initial ticket count
    local initialTickets = game:GetService("Players").LocalPlayer:WaitForChild("Tickets").Value
    local previousTicketCount = initialTickets

    while _G.TicketFarm == true do
        -- Check if the player's character exists in the Survivors folder
        if not characterInSurvivors then
            -- Retry finding the character if it doesn't exist
            characterInSurvivors = survivorsFolder:FindFirstChild(localPlayerName)
            wait(0.1)
            continue
        end

        local noRayFolder = workspace:WaitForChild("NoRay") -- Find the NoRay folder
        local ticketPart = noRayFolder:FindFirstChild("Ticket") -- Try to find the part named "Ticket"

        local targetPosition

        if ticketPart then
            -- If "Ticket" is found, use its position to teleport
            targetPosition = ticketPart.Position
        else
            -- If "Ticket" is not found, teleport to the sky position (0, 1000, 0)
            targetPosition = Vector3.new(0, 1000, 0)
        end

        -- Enable noclip for the character
        enableNoclip(characterInSurvivors)

        -- Ensure the character has a HumanoidRootPart
        local humanoidRootPart = characterInSurvivors:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Set the Lerp parameters
            local startPosition = humanoidRootPart.Position
            local steps = 3 -- Number of interpolation steps
            local duration = 0.1 -- Total time to complete the teleport (in seconds)
            local stepDuration = duration / steps -- Time per step

            -- Add a BodyVelocity to set velocity to 0
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = humanoidRootPart

            -- Smooth Lerp movement
            for i = 1, steps do
                -- Calculate the interpolation progress
                local progress = i / steps
                -- Add wobble effect
                local wobbleOffset = Vector3.new(
                    math.random(-5, 5) * 0.1, -- Small random x offset
                    math.random(-5, 5) * 0.1, -- Small random y offset
                    math.random(-5, 5) * 0.1  -- Small random z offset
                )
                local wobblePosition = targetPosition + wobbleOffset

                -- Move the HumanoidRootPart incrementally
                humanoidRootPart.CFrame = CFrame.new(startPosition:Lerp(wobblePosition, progress))
                wait(stepDuration) -- Wait for the next step
            end

            -- Ensure the final position is exactly the target position
            humanoidRootPart.CFrame = CFrame.new(targetPosition)

            -- Cleanup: Remove BodyVelocity
            bodyVelocity:Destroy()
        end

        wait(0.1) -- Add slight delay for smoother wobbling
    end

    -- Once TicketFarm is turned off, teleport the character to the nearest model in Survivors
    if _G.TicketFarm == false then
        -- Find the nearest model in Survivors
        local closestDistance = math.huge
        local closestModel = nil

        for _, survivor in pairs(survivorsFolder:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                local distance = (characterInSurvivors.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestModel = survivor
                end
            end
        end

        -- Teleport the character to the closest survivor
        if closestModel then
            local targetHumanoidRootPart = closestModel:FindFirstChild("HumanoidRootPart")
            if targetHumanoidRootPart then
                characterInSurvivors.HumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame
            end
        end
    end

    -- Re-enable collision for the character after farming stops
    disableNoclip(characterInSurvivors)

    -- Calculate and show the tickets gained after farming stops
    local finalTicketCount = game:GetService("Players").LocalPlayer:WaitForChild("Tickets").Value
    local ticketsGained = finalTicketCount - previousTicketCount

    -- Send notification with the results
    library:SendNotification("You gained " .. ticketsGained .. " tickets!", 5, Color3.new(128, 0, 128))
end

sections.Section2:AddToggle({
    text = "Ticket farm (TEMP DISABLED)",
    flag = "Toggle_1",
    callback = function(v)
        _G.TicketFarm = v
        if v then
            TicketFarm()
        end
    end
})












_G.ModDetector = true

function ModDetector()
    while _G.ModDetector == true do
-- List of usernames to detect
local blacklistedNames = {
    "c4rpye", "scott1333", "sagecrisi_s", "JackLighters", "alum_i", 
    "Masterdude180", "drinkyz", "IDunhill", "Dr_Greedster", "Tekrinn", 
    "TheeOfficalOG", "ur_lucky", "Synween", "mrvriie", "QtAdomi"
}

-- Get the Players service
local players = game:GetService("Players")

-- Function to check for blacklisted players
local function checkForBlacklistedPlayers()
    for _, player in ipairs(players:GetPlayers()) do
        if table.find(blacklistedNames, player.Name) then
            -- Kick the local player if a blacklisted name is found
            players.LocalPlayer:Kick("Mod detected: " .. player.Name)
            break
        end
    end
end

-- Connect to the PlayerAdded event to check new players joining
players.PlayerAdded:Connect(function(newPlayer)
    if table.find(blacklistedNames, newPlayer.Name) then
        players.LocalPlayer:Kick("Mod detected: " .. newPlayer.Name)
    end
end)

-- Initial check for players already in the game
checkForBlacklistedPlayers()

        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Mod Detector",
    flag = "Toggle_1",
    callback = function(v)
        _G.ModDetector  = v
        ModDetector()
    end
})







_G.PunchSound = true

function PunchSound()
    while _G.PunchSound == true do
        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Punch"
local ohNumber2 = 1

game:GetService("ReplicatedStorage").Events.Survivor.SoundFire:FireServer(ohString1, ohNumber2)

local ohString1 = "Punch"
local ohNumber2 = 3

game:GetService("ReplicatedStorage").Events.Survivor.SoundFire:FireServer(ohString1, ohNumber2)

        wait(0.001)
    end
end



sections.Section1:AddToggle({
    text = "Punch spam sound",
    flag = "Toggle_1",
    callback = function(v)
        _G.PunchSound  = v
        PunchSound()
    end
})







_G.AutoVoteMap = true

function AutoVoteMap()
    while _G.AutoVoteMap == true do
        local ohString1 = "Shoot'em up Town"
        local ohString2 = "Survival Unlimited"
        local ohString3 = "Sunny Day"
        
        game:GetService("ReplicatedStorage").Events.VoteMap:FireServer(ohString1, ohString2, ohString3)
        
        _G.VoteNo = true
        
        function VoteNo()
            while _G.VoteNo == true do
                local ohNumber1 = -1
        
                game:GetService("ReplicatedStorage").Events.Vote:FireServer(ohNumber1)
                wait(0.001)
            end
        end
        wait(0.1)
    end
end



sections.Section2:AddToggle({
    text = "Auto vote map",
    flag = "Toggle_1",
    callback = function(v)
        _G.AutoVoteMap  = v
        AutoVoteMap()
    end
})




-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide





sections.Section1:AddToggle({
    text = "Vote No to maps",
    flag = "Toggle_1",
    callback = function(v)
        _G.VoteNo  = v
        VoteNo()
    end
})


_G.GiftTp = true







function GiftTp()
    while _G.GiftTp == true do
-- List of target names
local targetNames = {
    "Aqua Gift",
    "Common Gift",
    "Gift of Fortune",
    "Gift of Kindness",
    "Gift of Life",
    "Golden Gift",
    "Legendary Gift",
    "Rare Gift"
}

-- Function to check if the player is inside workspace.Characters.Survivors
local function isPlayerInSurvivors()
    -- Get the Players service
    local players = game:GetService("Players")
    local player = players.LocalPlayer
    
    -- Check if the player's character exists
    if not player or not player.Character then
        return false
    end

    -- Check if the player's character is inside workspace.Characters.Survivors
    return workspace.Characters:FindFirstChild("Survivors") and workspace.Characters.Survivors:FindFirstChild(player.Character.Name)
end

-- Function to check if the player owns a specific gift
local function doesPlayerOwnGift(giftName)
    local player = game:GetService("Players").LocalPlayer
    local inventory = player:FindFirstChild("INVENTORY")
    
    -- Ensure the inventory and Secondary exist
    if not inventory or not inventory:FindFirstChild("Secondary") then
        return false
    end

    -- Check if the specific gift exists in the Secondary inventory
    for _, item in pairs(inventory.Secondary:GetChildren()) do
        if item.Name == giftName then
            return true -- Player already owns this specific gift
        end
    end
    
    return false -- Gift not found in inventory
end

-- Function to teleport the player to a gift if in the correct area, and return them back
local function teleportToGift()
    -- Get the Players service
    local players = game:GetService("Players")
    local player = players.LocalPlayer

    -- Check if the player is inside workspace.Characters.Survivors
    if not isPlayerInSurvivors() then
        -- Send notification if the player is not inside Survivors
        print("")
        return
    end

    -- Store the player's current position
    local initialPosition = player.Character.HumanoidRootPart.CFrame

    -- Flag to check if a gift was found
    local giftFound = false

    -- Iterate through each object in workspace.Map
    for _, object in pairs(workspace.Map:GetChildren()) do
        -- Check if the object is a model or part and if its name matches any of the target names
        for _, name in ipairs(targetNames) do
            if object.Name == name then
                -- Check if the player already owns this specific gift
                if doesPlayerOwnGift(name) then
                    library:SendNotification("You already own: " .. name, 5, Color3.new(255, 255, 0)) -- Yellow for owned gift
                    return -- Stop processing if the gift is owned
                end

                -- If the player does not own the gift, teleport to its location
                player.Character.HumanoidRootPart.CFrame = object.CFrame
                -- Notify that the player was teleported
                library:SendNotification("Teleported to: " .. name, 5, Color3.new(0, 255, 0)) -- Green for success
                giftFound = truea

                -- Wait for a moment (if necessary) before moving the player back 1 stud
                wait(0.15)

                -- Move the player 1 stud backwards (adjusting the CFrame)
                local backPosition = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
                player.Character.HumanoidRootPart.CFrame = backPosition

                -- Simulate the jump (apply force to the Humanoid)
                local humanoid = player.Character:WaitForChild("Humanoid")
                wait(0.1) -- Wait for the jump to be initiated (adjust as necessary)

                -- Teleport the player back to their initial position
                player.Character.HumanoidRootPart.CFrame = initialPosition
                -- Notify that the player is back at their original location
                library:SendNotification("Teleported back", 5, Color3.new(0, 0, 255)) -- Blue for teleport back
                return -- Stop the loop after teleporting
            end
        end
    end

    -- If no gift was found, send a notification
    if not giftFound then
        library:SendNotification("No Gift Found", 5, Color3.new(255, 0, 0)) -- Red for error
    end
end

-- Call the function to teleport to the first gift found
teleportToGift()


        wait(1)
    end
end






sections.Section2:AddToggle({
    text = "Teleport to gifts",
    flag = "Toggle_1",
    callback = function(v)
        _G.GiftTp  = v
        GiftTp()
    end
})


-- This script will kick the local player if any other player leaves the game.
-- Place this in a LocalScript, such as in StarterPlayerScripts.

local Players = game:GetService("Players")

-- Auto-leave functionality using a loop and global toggle
_G.AutoLeave = false

function AutoLeave()
    while _G.AutoLeave do
-- Place this LocalScript in StarterPlayerScripts

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Function to check the player count and kick if needed
local function checkPlayerCount()
    local playerCount = #Players:GetPlayers()
    if playerCount < 10 then
        LocalPlayer:Kick("Player left! (Sync.wtf Saved u from a ban)")
    end
end

-- Connect to the PlayerAdded and PlayerRemoving events
Players.PlayerAdded:Connect(checkPlayerCount)
Players.PlayerRemoving:Connect(checkPlayerCount)

-- Initial check in case the server starts with less than 10 players
checkPlayerCount()

        wait(1)
    end
end

-- Connect toggle functionality
local function onToggleLeave(v)
    _G.AutoLeave = v
    if _G.AutoLeave then
        AutoLeave()
    end
end

-- Example of how the toggle might be connected in a UI library
sections.Section2:AddToggle({
    text = "Leave if player dc's",
    flag = "Toggle_1",
    callback = onToggleLeave
})







sections.Section2:AddSeparator({
    enabled = true,
    text = "Anti lag"
})




_G.AntiLag = true
function AntiLag()
    while _G.AntiLag == true do 
        -- Get the "NoRay" workspace
local noRayWorkspace = game.Workspace:FindFirstChild("NoRay")

-- Check if the "NoRay" workspace exists
if noRayWorkspace then
    -- Loop through all the objects in the "NoRay" workspace
    for _, part in pairs(noRayWorkspace:GetChildren()) do
        -- Check if the object's name is "Ticket"
        if part.Name == "Ticket" then
            -- Destroy the "Ticket" part
            part:Destroy()
        end
    end
else
    -- If "NoRay" doesn't exist, print a message
end
wait(0.5)
    end
end


sections.Section2:AddToggle({
    text = "Anti Lag (Removes tickets)",
    flag = "Toggle_1",
    callback = function(v)
        _G.AntiLag  = v
        AntiLag()
    end
})



sections.Section2:AddToggle({
    text = "Delete map",
    flag = "Toggle_1",
    callback = function(v) -- `v` is true when toggled on, false when toggled off
        if v then
            -- Toggle ON: Backup and clear workspace.Map
            for i, child in pairs(workspace.Map:GetChildren()) do
                backupMap[child.Name] = child -- Save reference to each child
                child.Parent = nil -- Remove from workspace.Map
            end
            library:SendNotification("Map cleared.", 5, Color3.new(128, 0, 128))
        else
            -- Toggle OFF: Restore workspace.Map
            for name, child in pairs(backupMap) do
                child.Parent = workspace.Map -- Reparent back to workspace.Map
            end
            backupMap = {} -- Clear the backup to avoid duplication
            library:SendNotification("Map restored.", 5, Color3.new(128, 0, 128))
        end
    end
})

_G.UselessStuff = true
function UselessStuff()
    while _G.UselessStuff == true do
-- Script to remove objects named "Part", "Toxic", and "Rain" under workspace.NoRay

-- Ensure the workspace.NoRay exists
if workspace:FindFirstChild("NoRay") then
    for _, child in pairs(workspace.NoRay:GetChildren()) do
        -- Check if the object's Name is "Part", "Toxic", or "Rain"
        if child.Name == "Part" or child.Name == "Toxic" or child.Name == "Rain" then
            child:Destroy() -- Remove the object
        end
    end
else
    warn("workspace.NoRay does not exist.")
end

wait(0.1)

    end
end


sections.Section2:AddToggle({
    text = "Delete useless stuff",
    flag = "Toggle_1",
    callback = function(v) 
        _G.UselessStuff = v
            UselessStuff()
    end
})





sections.Section2:AddSeparator({
    enabled = true,
    text = "Kill aura"
})


_G.MeleeKillAura = true



function MeleeKillAura()
    while _G.MeleeKillAura == true do
       -- Define a list of allowed tools
local allowedTools = {
    "Chainsaw",
    "Fireaxe"
}

-- Function to check if a tool is allowed
local function isToolAllowed(toolName)
    for _, allowedTool in ipairs(allowedTools) do
        if toolName == allowedTool then
            return true
        end
    end
    return false
end

local zombies = workspace.Characters.Zombies
local survivors = workspace.Characters.Survivors
local player = game:GetService("Players").LocalPlayer

-- Iterate through each tool in the player's backpack
for _, tool in pairs(player.Backpack:GetChildren()) do
    -- Check if the item is a Tool, is in the allowedTools list, and has a 'Slash' event
    if tool:IsA("Tool") and isToolAllowed(tool.Name) and tool:FindFirstChild("Slash") then
        -- Iterate through each zombie in workspace.Characters.Zombies
        for _, zombie in pairs(zombies:GetChildren()) do
            -- Ensure the zombie has a Head and Humanoid
            if zombie:FindFirstChild("Head") and zombie:FindFirstChild("Humanoid") then
                local head = zombie.Head
                local humanoid = zombie.Humanoid

                -- Prepare the table with necessary info for the Slash
                local ohTable2 = {
                    ["HeadShot"] = true,
                    ["Humanoid"] = humanoid,
                    ["Combo"] = 1,
                    ["Weapon"] = tool,
                    ["NoStruggle"] = true
                }

                -- Fire the Slash event for each zombie
                tool.Slash:FireServer(head, ohTable2)
            end
        end

        -- Iterate through each survivor in workspace.Characters.Survivors
        for _, survivor in pairs(survivors:GetChildren()) do
            -- Ensure the survivor has a Head and Humanoid
            if survivor:FindFirstChild("Head") and survivor:FindFirstChild("Humanoid") then
                local head = survivor.Head
                local humanoid = survivor.Humanoid

                -- Prepare the table with necessary info for the Slash
                local ohTable2 = {
                    ["HeadShot"] = true,
                    ["Humanoid"] = humanoid,
                    ["Combo"] = 1,
                    ["Weapon"] = tool,
                    ["NoStruggle"] = true
                }

                -- Fire the Slash event for each survivor
                tool.Slash:FireServer(head, ohTable2)
            end
        end
    end
end
wait(0.01)
        
    end
end

sections.Section2:AddToggle({
    text = "Melee kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.MeleeKillAura = v
            MeleeKillAura()
    end
})



_G.TpZombies = true

function TpZombies()
    -- Disable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end

    -- Get a reference to the player's character
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    if playerCharacter then
        local humanoidRootPartPlayer = playerCharacter:WaitForChild("HumanoidRootPart", 10)
        local humanoid = playerCharacter:FindFirstChild("Humanoid")

        if humanoidRootPartPlayer and humanoid then
            -- Prevent the character from falling by disabling gravity and setting PlatformStand
            humanoid.PlatformStand = true
            humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)  -- Stop velocity to prevent falling
        end
    end





    while _G.TpZombies == true do
        -- Get a reference to the Zombies folder in the workspace
        local zombiesFolder = game.Workspace.Characters.Zombies

        -- Define a fallback position in the sky
        local skyPosition = Vector3.new(0, 1000, 0)  -- You can adjust the Y value to determine how high in the sky

        -- Get the player's character
        local playerCharacter = game:GetService("Players").LocalPlayer.Character
        if playerCharacter then
            -- Get the player's HumanoidRootPart and Humanoid
            local humanoidRootPartPlayer = playerCharacter:WaitForChild("HumanoidRootPart", 10)  -- Waits for up to 10 seconds
            local humanoid = playerCharacter:FindFirstChild("Humanoid")

            if humanoidRootPartPlayer and humanoid then
                -- Temporarily set the velocity of the player's HumanoidRootPart to zero to prevent fall damage
                humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)

                -- Perform teleportation logic here
                -- Check if the Zombies folder exists and has models in it
                if zombiesFolder and #zombiesFolder:GetChildren() > 0 then
                    -- Get a random model from the Zombies folder
                    local randomZombie = zombiesFolder:GetChildren()[math.random(1, #zombiesFolder:GetChildren())]

                    -- Check if the model has a HumanoidRootPart
                    local humanoidRootPart = randomZombie:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        -- Get the position of the HumanoidRootPart and add a Y offset of 15 studs
                        local targetPosition = humanoidRootPart.Position + Vector3.new(0, -13, 0)

                        -- Teleport the player to the new position
                        playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))
                    else
                    end
                else

                    -- If no zombies are found, teleport the player to the sky
                    local skyPosition = Vector3.new(0, 1000, 0) -- Sky position
                    playerCharacter:SetPrimaryPartCFrame(CFrame.new(skyPosition))
                end
            else
            end
        else
        end

        wait(0.05)
    end
end

-- Function to stop teleportation, restore collisions, re-enable gravity for the player, and teleport them 20 studs in the air
function stopTpZombies()
    -- Enable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end

    -- Get the player's character
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    if playerCharacter then
        local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
        local humanoid = playerCharacter:FindFirstChild("Humanoid")

        if humanoidRootPartPlayer and humanoid then
            -- Teleport the player 20 studs in the air (along the Y-axis)
            local currentPosition = humanoidRootPartPlayer.Position
            local targetPosition = currentPosition + Vector3.new(0, 20, 0)

            -- Teleport the player to the new position
            playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))

            -- Re-enable gravity and stop PlatformStand
            humanoid.PlatformStand = false
            humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)  -- Reset velocity
        end
    end
end

sections.Section2:AddToggle({
    text = "Teleport to Zombies",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpZombies = v
        if _G.TpZombies then
            TpZombies()
        else
            stopTpZombies()
        end
    end
})





_G.TpSurvivors = true

function TpSurvivors()
    -- Disable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end

    while _G.TpSurvivors == true do
        -- Get a reference to the Survivors folder in the workspace
        local survivorsFolder = game.Workspace.Characters.Survivors

        -- Define a fallback position in the sky
        local skyPosition = Vector3.new(0, 1000, 0)  -- You can adjust the Y value to determine how high in the sky

        -- Check if the Survivors folder exists and has models in it
        if survivorsFolder and #survivorsFolder:GetChildren() > 0 then
            -- Get a random model from the Survivors folder
            local randomSurvivor = survivorsFolder:GetChildren()[math.random(1, #survivorsFolder:GetChildren())]

            -- Check if the model has a HumanoidRootPart
            local humanoidRootPart = randomSurvivor:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Get the position of the HumanoidRootPart and add a Y offset of 12.5 studs
                local targetPosition = humanoidRootPart.Position + Vector3.new(0, -10, 0)

                -- Get the player's character
                local playerCharacter = game:GetService("Players").LocalPlayer.Character

                -- Check if the player has a HumanoidRootPart and a Humanoid
                local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
                local humanoid = playerCharacter:FindFirstChild("Humanoid")

                if humanoidRootPartPlayer and humanoid then
                    -- Temporarily set the velocity of the player's HumanoidRootPart to zero
                    humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)

                    -- Teleport the player to the new position
                    playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))
                else
                    warn("Player does not have a HumanoidRootPart or Humanoid.")
                end
            else
                warn("Random survivor model does not have a HumanoidRootPart.")
            end
        else
            warn("No survivors found in the Survivors folder.")

            -- If no survivors are found, teleport the player to the sky
            local playerCharacter = game:GetService("Players").LocalPlayer.Character
            local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
            if humanoidRootPartPlayer then
                -- Temporarily set the velocity to 0 to prevent fall damage
                humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)
                -- Teleport the player to the sky position
                playerCharacter:SetPrimaryPartCFrame(CFrame.new(skyPosition))
            else
                warn("Player does not have a HumanoidRootPart.")
            end
        end

        wait(0.15)
    end
end

function stopTpSurvivors()
    -- Enable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end

    -- Teleport the player 15 studs up
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPartPlayer then
        -- Get the current position and add 15 studs to the Y-coordinate
        local currentPosition = humanoidRootPartPlayer.Position
        local newPosition = currentPosition + Vector3.new(0, 15, 0)

        -- Teleport the player to the new position
        playerCharacter:SetPrimaryPartCFrame(CFrame.new(newPosition))
    else
        warn("Player does not have a HumanoidRootPart.")
    end
end

sections.Section2:AddToggle({
    text = "Teleport to Survivors",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpSurvivors = v
        if _G.TpSurvivors then
            TpSurvivors()
        else
            stopTpSurvivors()
        end
    end
})




















sections.Section1:AddSeparator({
    enabled = true,
    text = "Zombie Exploits"
})





_G.SpamBlock = true

function SpamBlock()
    while _G.SpamBlock == true do
        local ohBoolean1 = true

    game:GetService("ReplicatedStorage").Events.Zombie.Block:FireServer(ohBoolean1)
local ohBoolean1 = true  
        wait(0.001)
    end
end









sections.Section1:AddToggle({
    text = "Spam block (Brute) Crasher/Lag",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
    end
})






sections.Section1:AddButton({
    enabled = true,
    text = "Digger invisibility",
    flag = "Button_1",
    tooltip = "Digger",
    confirm = false,
    risky = true,
    callback = function()     
-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Get the LocalPlayer's character and its HumanoidRootPart
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Get the LocalPlayer's CFrame
local playerCFrame = humanoidRootPart.CFrame

local ohString1 = "Enter"

-- Use the player's CFrame as the new CFrame
local ohCFrame2 = playerCFrame

-- Fire the server event with the updated CFrame
game:GetService("ReplicatedStorage").Events.Zombie.DiggerPower:FireServer(ohString1, ohCFrame2)

    end
})






_G.Elmspam = true

function Elmspam()
    while _G.Elmspam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor has health greater than 0
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to shoot at the closest survivor
local function shootAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.ElmM1:FireServer(shootPosition)

        -- Optionally, print a message for debugging
    end
end

-- Call the function to shoot at the closest survivor
shootAtClosestSurvivor()

        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "elm auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Elmspam  = v
        Elmspam()
    end
})

_G.Beespam = true

function Beespam()
    while _G.Beespam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to fire at the closest survivor
local function fireAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        local ohString1 = "Honey"  -- You can keep this string as is if needed
        game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(ohString1, shootPosition)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to fire at.")
    end
end

-- Call the function to fire at the closest survivor
fireAtClosestSurvivor()


        
        wait(0.0001)
    end
end



sections.Section1:AddToggle({
    text = "bee auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Beespam  = v
        Beespam()
    end
})



_G.HiveSpam = true

function HiveSpam()
    while _G.HiveSpam == true do
        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Charge"

game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(ohString1)

wait(0.01)

local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to shoot at the closest survivor
local function shootAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shotPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(shotPosition)

        -- Optionally, print a message for debugging
        print("Shooting at: " .. closestSurvivor.Name)
    else
        print("No survivors found to shoot at.")
    end
end

-- Call the function to shoot at the closest survivor
shootAtClosestSurvivor()


        wait(0.001)
    end
end



sections.Section1:AddToggle({
    text = "Hive auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.HiveSpam  = v
        HiveSpam()
    end
})















_G.EdgarSpam = true

function EdgarSpam()
    while _G.EdgarSpam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to fire at the closest survivor
local function fireAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.Tongue:FireServer({["Position"] = shootPosition}, true)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to fire at.")
    end
end

-- Call the function to fire at the closest survivor
fireAtClosestSurvivor()

        
        wait(0.001)
        
    end
end

        




sections.Section1:AddToggle({
    text = "Edgar auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.EdgarSpam  = v
        EdgarSpam()
    end
})

sections.Section1:AddSeparator({
    enabled = true,
    text = "Visuals"
})

-- Function for changing FOV
local function FovChanger2()
    local player = game:GetService("Players").LocalPlayer
    local camera = game:GetService("Workspace").CurrentCamera
    
    -- Loop to constantly change the FOV while toggle is on
    while _G.FovChanger2 do
        camera.FieldOfView = 120  -- Set the desired FOV to 120
        wait(0.1)  -- Wait for 0.5 seconds before updating again
    end
end

-- Add the toggle for changing FOV
sections.Section1:AddToggle({
    text = "Fov changer",  -- Toggle name
    flag = "Toggle_1",  -- Flag for state tracking
    callback = function(v)
        -- When the toggle is turned on
        if v then
            _G.FovChanger2 = true  -- Enable FOV change loop
            FovChanger2()  -- Start the function

        else
            -- When the toggle is turned off, set FOV to 90
            _G.FovChanger2 = false  -- Stop FOV change loop
            local player = game:GetService("Players").LocalPlayer
            local camera = game:GetService("Workspace").CurrentCamera
            camera.FieldOfView = 90  -- Set the FOV to 90
        end
    end
})

_G.ChangeFace = true
local function ChangeFace()
    while _G.ChangeFace == true do

local ohString1 = "X_X"

game:GetService("ReplicatedStorage").Events.Survivor.SetFace:FireServer(ohString1)


wait(0.1)
local ohString1 = "Normal"

game:GetService("ReplicatedStorage").Events.Survivor.SetFace:FireServer(ohString1)

wait(0.1)
local ohString1 = "Squint"

game:GetService("ReplicatedStorage").Events.Survivor.SetFace:FireServer(ohString1)
        wait(0.1)
    end
end

sections.Section1:AddToggle({
    text = "Change face",  -- Toggle name
    flag = "Toggle_1",  -- Flag for state tracking
    callback = function(v)
        _G.ChangeFace  = v
        ChangeFace()
    end
})






_G.ForcefieldWeapon = true

function ForcefieldWeapon()
    while _G.ForcefieldWeapon == true do
-- Get the local player using GetService
local player = game:GetService("Players").LocalPlayer

-- Check if player exists
if player then
    -- Get the Backpack of the player
    local backpack = player.Backpack

    -- Loop through all tools in the player's Backpack
    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            -- Loop through all parts in the tool and change their material and color
            for _, part in ipairs(tool:GetChildren()) do
                if part:IsA("BasePart") then
                    -- Change the material to ForceField
                    part.Material = Enum.Material.ForceField
                    
                    -- Change the color to red
                    part.Color = Color3.fromRGB(128, 0, 128)  -- RGB for red
                end
            end
        end
    end
else
    warn("LocalPlayer not found.")
end


        
        wait(0.25)
    end
end



sections.Section1:AddToggle({
    text = "ForceField weapon",
    flag = "Toggle_1",
    callback = function(v)
        _G.ForcefieldWeapon  = v
        ForcefieldWeapon()
    end
})








sections.Section1:AddToggle({
    text = "Esp",
    flag = "Toggle_1",
    callback = function(v)
        --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
local ESP = loadstring(game:HttpGet("https://raw.githubusercontent.com/pAdsasd3q2/Da98123412dsxf/refs/heads/main/Esp"))();

--// Master switch
ESP.Enabled = v;

--// Enable boxes
ESP.ShowBox = true;

--// Set the box type to corner
ESP.BoxType = "Corner Box Esp";

--// Enable names
ESP.ShowName = true;

--// Enable Healhbar
ESP.ShowHealth = false;

--// Enable tracers
ESP.ShowTracer = false;

--// Enable Distance
ESP.ShowDistance = true;

ESP.Teamcheck = true;




--[[
    Enable skeletons: (currently broken)
    ESP.ShowSkeletons = true;
]]



--[[
    These are all the settings
    local ESP_SETTINGS = {
        BoxOutlineColor = Color3.new(0, 0, 0),
        BoxColor = Color3.new(1, 1, 1),
        NameColor = Color3.new(1, 1, 1),
        HealthOutlineColor = Color3.new(0, 0, 0),
        HealthHighColor = Color3.new(0, 1, 0),
        HealthLowColor = Color3.new(1, 0, 0),
        CharSize = Vector2.new(4, 6),
        Teamcheck = false,
        WallCheck = false,
        Enabled = false,
        ShowBox = false,
        BoxType = "2D",
        ShowName = false,
        ShowHealth = false,
        ShowDistance = false,
        ShowSkeletons = false,
        ShowTracer = false,
        TracerColor = Color3.new(1, 1, 1), 
        TracerThickness = 2,
        SkeletonsColor = Color3.new(1, 1, 1),
        TracerPosition = "Bottom",
    }
    ermm yep thats about it
]]



    end
})



-- Assuming you're using a UI library where sections and toggles are defined.

-- Assuming you're using a UI library where sections and toggles are defined.

local Lighting = game:GetService("Lighting")

-- Define the functions for applying and reverting the ambience
local function applyPurpleAmbience()
    if Lighting then
        Lighting.Ambient = Color3.fromRGB(128, 0, 128)
        Lighting.OutdoorAmbient = Color3.fromRGB(75, 0, 130)
        Lighting.ColorShift_Bottom = Color3.fromRGB(48, 0, 64)
        Lighting.ColorShift_Top = Color3.fromRGB(153, 51, 153)
        Lighting.Brightness = 2
        Lighting.ClockTime = 19
        Lighting.FogColor = Color3.fromRGB(75, 0, 130)
        Lighting.FogEnd = 200
        print("Purple ambience applied!")   
    else
        warn("Lighting service is unavailable!")
    end
end

local function revertAmbience()
    if Lighting then
        Lighting.Ambient = Color3.fromRGB(127, 127, 127) -- Default grey
        Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127) -- Default grey
        Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0) -- Default black
        Lighting.ColorShift_Top = Color3.fromRGB(0, 0, 0) -- Default black
        Lighting.Brightness = 2 -- Default brightness
        Lighting.ClockTime = 12 -- Noon time
        Lighting.FogColor = Color3.fromRGB(255, 255, 255) -- Default white fog
        Lighting.FogEnd = 100000 -- Practically no fog
        print("Ambience reverted to default!")
    else
        warn("Lighting service is unavailable!")
    end
end

-- Add the toggle to the section within your UI framework
sections.Section1:AddToggle({
    text = "Ambience changer", 
    flag = "Toggle_1",
    callback = function(isEnabled)
        if isEnabled then
            print("Toggle is ON. Applying purple ambience.")
            applyPurpleAmbience()  -- Apply the purple ambience when the toggle is true
        else
            print("Toggle is OFF. Reverting ambience.")
            revertAmbience()  -- Revert to the default lighting when the toggle is false
        end
    end
})





-------------------------------------------------------------------
-- Initialize the global toggle if it doesn't exist
if not _G.ForceFieldnCharacter then
    _G.ForceFieldnCharacter = false
end

-- Get the Players service
local Players = game:GetService("Players")

-- Get the local player
local player = Players.LocalPlayer

-- Function to update body part material and color
local function updateBodyParts()
    -- Find the character in the Survivors folder
    local character = workspace.Characters.Survivors:FindFirstChild(player.Name)
    
    if character then
        for _, part in pairs(character:GetChildren()) do
            -- Check if the part is a BasePart (such as a torso, head, etc.)
            if part:IsA("BasePart") then
                if _G.ForceFieldnCharacter then
                    -- Change the material to ForceField and color to purple
                    part.Material = Enum.Material.ForceField
                    part.Color = Color3.fromRGB(128, 0, 128)  -- Purple
                else
                    -- Revert the material to Plastic and set the color to the default (white)
                    part.Material = Enum.Material.Plastic
                    part.Color = Color3.fromRGB(255, 255, 255)  -- White (default)
                end
            end
        end
    end
end

-- Toggle Function (to be called by the button)
function ForceFieldnCharacter()
    -- Continuously check and update the body parts when the toggle is on
    while _G.ForceFieldnCharacter do
        updateBodyParts()  -- Update the character appearance
        wait(0.1)  -- Update every 0.1 seconds to avoid performance issues
    end
end





-- Adding toggle to the UI
sections.Section1:AddToggle({
    text = "ForceField Character",  -- Toggle text
    flag = "Toggle_1",              -- Unique flag for this toggle
    callback = function(v)
        -- Set the global variable based on the toggle state
        _G.ForceFieldnCharacter = v

        -- If the toggle is turned on, start updating body parts
        if v then
            ForceFieldnCharacter()  -- Begin updating when enabled
        else
            updateBodyParts()  -- Revert changes when disabled
        end
    end
})





sections.Section1:AddSeparator({
    enabled = true,
    text = "Hammer"
})



sections.Section1:AddButton({
    enabled = true,
    text = "Sky scraper",
    flag = "Button_1",
    tooltip = "Needs hammer",
    confirm = false,
    risky = true,
    callback = function()     
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        
        local hammer = workspace.Characters.Survivors:FindFirstChild(player.Name):FindFirstChild("Hammer")
        local event = game:GetService("ReplicatedStorage").Events.UseItem
        local buildType = "Build"
        local towerName = "Tower"
        
        -- Parameters for the stack
        local numTowers = 20 -- Number of towers to stack
        local yIncrement = 17 -- Distance between towers on the Y-axis
        local forwardOffset = 5 -- Distance in front of the player to spawn the 
        
        local function createStack()
            local rootPart = character:WaitForChild("HumanoidRootPart")
            local startPosition = rootPart.Position + (rootPart.CFrame.LookVector * forwardOffset)
        
            for i = 0, numTowers - 1 do
                local towerPosition = startPosition + Vector3.new(0, i * yIncrement, 0)
                local towerCFrame = CFrame.new(towerPosition)
        
                -- Build the tower at the calculated position
                event:FireServer(hammer, buildType, {
                    ["Name"] = towerName,
                    ["Cframe"] = towerCFrame
                })
            end
        end
        
        -- Call the function to create the stack
        createStack()
        


    end
})


sections.Section1:AddButton({
    enabled = true,
    text = "Vertical Sky scraper",
    flag = "Button_1",
    tooltip = "Needs hammer",
    confirm = false,
    risky = true,
    callback = function()     
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        -- Ensure that the character has a HumanoidRootPart to get its position and orientation
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        -- Get the LocalPlayer's position and facing direction
        local playerPosition = humanoidRootPart.Position
        local lookVector = humanoidRootPart.CFrame.LookVector

        -- Define the spacing and number of towers
        local spacing = 18 -- Distance between each tower
        local towerCount = 20 -- Total number of towers

        -- Locate the hammer instance dynamically
        local hammerInstance = nil
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == "Hammer" then
                hammerInstance = tool
                break
            end
        end

        if not hammerInstance then
            warn("Hammer not found! Equip your hammer and try again.")
            return
        end

        -- Iterate to place 20 towers
        for i = 1, towerCount do
            -- Calculate the position for each tower
            local adjustedPosition = playerPosition + (lookVector * (10 + (i - 1) * spacing)) - Vector3.new(0, 5, 0)

            -- Determine the 9th number (facing direction) in the rotation matrix
            local facingValue = lookVector.Z > 0 and 1 or 0

            -- Define the rotation matrix dynamically
            local rotationMatrix = CFrame.new(0, 0, 0, 1, 43, 0, 0, 43, 0, 0, 0, facingValue)

            -- Combine the adjusted position with the rotation matrix
            local ohTable3 = {
                ["Name"] = "Tower",
                ["Cframe"] = CFrame.new(adjustedPosition) * rotationMatrix
            }

            -- Fire the server event to place the tower
            game:GetService("ReplicatedStorage").Events.UseItem:FireServer(hammerInstance, "Build", ohTable3)
        end
    end
})



sections.Section1:AddButton({
    enabled = true,
    text = "Cage Nearest",
    flag = "Button_1",
    tooltip = "Need hammer",
    confirm = false,
    risky = true,
    callback = function()     
        -- Assuming local player
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        -- Locate the hammer instance dynamically
        local hammerInstance = nil
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == "Hammer" then
                hammerInstance = tool
                break
            end
        end

        if not hammerInstance then
            warn("Hammer not found! Equip your hammer and try again.")
            return
        end

        -- Helper function to spawn objects at a given CFrame
        local function spawnObject(position)
            local ohTable3 = {
                ["Name"] = "Tower",
                ["Cframe"] = CFrame.new(position)
            }

            -- Fire the event to use the item at the position
            game:GetService("ReplicatedStorage").Events.UseItem:FireServer(hammerInstance, "Build", ohTable3)
        end

        -- Find the closest model in workspace.Characters.Survivors excluding the LocalPlayer
        local closestModel = nil
        local closestDistance = math.huge  -- Start with a very large number

        for _, model in pairs(workspace.Characters.Survivors:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and model ~= character then
                -- Calculate the distance to the model, but exclude the LocalPlayer's character
                local distance = (humanoidRootPart.Position - model.HumanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestModel = model
                end
            end
        end

        if closestModel then
            -- Parameters for the circle and position
            local radius = 5  -- Reduced radius for the circle
            local angleOffset = math.pi / 2  -- Offset angle to ensure it starts from the front
            local lowerAmount = 10  -- Lower the towers by 10 studs (adjustable)
            local topTowerHeight = 3  -- The height for the top tower, above the closest model

            -- Spawn the 4 objects in a circle around the closest model (lowered towers)
            for i = 0, 3 do
                local angle = angleOffset + (i * math.pi / 2)  -- Each object is placed 90 degrees apart
                local x = closestModel.HumanoidRootPart.Position.X + radius * math.cos(angle)
                local z = closestModel.HumanoidRootPart.Position.Z + radius * math.sin(angle)
                
                -- Lower the other towers significantly
                local y = closestModel.HumanoidRootPart.Position.Y - lowerAmount  

                spawnObject(Vector3.new(x, y, z))
            end

            -- Spawn the object on top of the closest model (keep it at a higher height)
            spawnObject(Vector3.new(closestModel.HumanoidRootPart.Position.X, closestModel.HumanoidRootPart.Position.Y + topTowerHeight, closestModel.HumanoidRootPart.Position.Z))
        end    
    end
})


sections.Section1:AddSeparator({
    enabled = true,
    text = "Fortnite"
})

sections.Section1:AddButton({
    enabled = true,
    text = "Place 1 Tower",
    flag = "Button_1",
    tooltip = "Needs hammer",
    confirm = false,
    risky = true,
    callback = function()     
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        
        local hammer = workspace.Characters.Survivors:FindFirstChild(player.Name):FindFirstChild("Hammer")
        local event = game:GetService("ReplicatedStorage").Events.UseItem
        local buildType = "Build"
        local towerName = "Tower"
        
        -- Parameters for the stack
        local numTowers = 1 -- Number of towers to stack
        local yIncrement = 15 -- Distance between towers on the Y-axis
        local forwardOffset = 5 -- Distance in front of the player to spawn the stack
        
        local function createStack()
            local rootPart = character:WaitForChild("HumanoidRootPart")
            local startPosition = rootPart.Position + (rootPart.CFrame.LookVector * forwardOffset)
        
            for i = 0, numTowers - 1 do
                local towerPosition = startPosition + Vector3.new(0, i * yIncrement, 0)
                local towerCFrame = CFrame.new(towerPosition)
        
                -- Build the tower at the calculated position
                event:FireServer(hammer, buildType, {
                    ["Name"] = towerName,
                    ["Cframe"] = towerCFrame
                })
            end
        end
        
        -- Call the function to create the stack
        createStack()
        


    end
})





sections.Section1:AddButton({
    enabled = true,
    text = "Place 1 vertical tower",
    flag = "Button_1",
    tooltip = "Needs hammer",
    confirm = false,
    risky = true,
    callback = function()     
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        -- Ensure that the character has a HumanoidRootPart to get its position and orientation
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        -- Get the LocalPlayer's position and facing direction
        local playerPosition = humanoidRootPart.Position
        local lookVector = humanoidRootPart.CFrame.LookVector

        -- Define the spacing and number of towers
        local spacing = 18 -- Distance between each tower
        local towerCount = 1 -- Total number of towers

        -- Locate the hammer instance dynamically
        local hammerInstance = nil
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == "Hammer" then
                hammerInstance = tool
                break
            end
        end

        if not hammerInstance then
            warn("Hammer not found! Equip your hammer and try again.")
            return
        end

        -- Iterate to place 20 towers
        for i = 1, towerCount do
            -- Calculate the position for each tower
            local adjustedPosition = playerPosition + (lookVector * (10 + (i - 1) * spacing)) - Vector3.new(0, 5, 0)

            -- Determine the 9th number (facing direction) in the rotation matrix
            local facingValue = lookVector.Z > 0 and 1 or 0

            -- Define the rotation matrix dynamically
            local rotationMatrix = CFrame.new(0, 0, 0, 1, 43, 0, 0, 43, 0, 0, 0, facingValue)

            -- Combine the adjusted position with the rotation matrix
            local ohTable3 = {
                ["Name"] = "Tower",
                ["Cframe"] = CFrame.new(adjustedPosition) * rotationMatrix
            }

            -- Fire the server event to place the tower
            game:GetService("ReplicatedStorage").Events.UseItem:FireServer(hammerInstance, "Build", ohTable3)
        end
    end
})


sections.Section1:AddButton({
    enabled = true,
    text = "Platform",
    flag = "Button_1",
    tooltip = "Needs hammer",
    confirm = false,
    risky = true,
    callback = function()     
        -- Get the LocalPlayer's position
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local character = localPlayer.Character
local rootPart = character:FindFirstChild("HumanoidRootPart") -- Ensure the root part exists

if rootPart then
    -- Use the LocalPlayer's name dynamically
    local ohInstance1 = workspace.Characters.Survivors[localPlayer.Name].Hammer
    local ohString2 = "Build"

    -- Define positions for the sandbags (front and back)
    local positions = {
        rootPart.CFrame * CFrame.new(0, -3, -3),   -- Behind the player
        rootPart.CFrame * CFrame.new(0, -3, 3),    -- In front of the player
    }

    -- Create sandbags at the defined positions
    for _, position in ipairs(positions) do
        local ohTable3 = {
            ["Name"] = "Sandbags",
            ["Cframe"] = position
        }
        game:GetService("ReplicatedStorage").Events.UseItem:FireServer(ohInstance1, ohString2, ohTable3)
    end
else
    warn("HumanoidRootPart not found for the LocalPlayer!")
end

    end
})







_G.ZombieKillAura = true

function ZombieKillAura()
    while _G.ZombieKillAura == true do
        local survivorsFolder = workspace.Characters.Survivors

        -- Loop through all the models in the Survivors folder
        for _, survivor in pairs(survivorsFolder:GetChildren()) do
            -- Check if the survivor model has the necessary parts
            local humanoid = survivor:FindFirstChild("Humanoid")
            local humanoidRootPart = survivor:FindFirstChild("HumanoidRootPart")
            
            -- Only proceed if both the Humanoid and HumanoidRootPart exist
            if humanoid and humanoidRootPart then
                -- Fire the event for each survivor
                game:GetService("ReplicatedStorage").Events.Zombie.ClawAttacked:FireServer(humanoid, nil, nil, humanoidRootPart)
            end
        end
        
        wait(0.01)
    end
end



sections.Section2:AddToggle({
    text = "Zombie kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.ZombieKillAura  = v
        ZombieKillAura()
    end
})




_G.SpearKillAura = true

function SpearKillAura()
    while _G.SpearKillAura == true do
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        
        -- Get the workspace service
        local workspace = game:GetService("Workspace")
        
        -- Find all models in workspace.Characters.Zombies
        local zombies = workspace.Characters.Zombies:GetChildren()
        
        -- Initialize variables to track the closest model and the shortest distance
        local closestZombie = nil
        local closestDistance = math.huge  -- Start with a very large number
        
        -- Iterate through all zombies and find the closest one
        for _, zombie in pairs(zombies) do
            if zombie:IsA("Model") and zombie:FindFirstChild("HumanoidRootPart") then
                local zombiePosition = zombie.HumanoidRootPart.Position
                local distance = (humanoidRootPart.Position - zombiePosition).Magnitude
        
                if distance < closestDistance then
                    closestDistance = distance
                    closestZombie = zombie
                end
            end
        end
        
        -- If a closest zombie is found, fire the remote event
        if closestZombie then
            -- Get the position of the closest zombie
            local targetPosition = closestZombie.HumanoidRootPart.Position
        
            -- Create the table with the new MousePos as the closest zombie's position
            local ohTable1 = {
                ["MousePos"] = targetPosition
            }
        
            -- Fire the event with the new position
            workspace.Characters.Survivors.ShadowBlaze2814.Spear.Throw:FireServer(ohTable1)
        else
            warn("No zombies found in workspace.Characters.Zombies!")
        end
        
        wait(0.001)
    end
end



sections.Section2:AddToggle({
    text = "Spear kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpearKillAura  = v
        SpearKillAura()
    end
})



_G.SpearGround = true

function SpearGround()
    while _G.SpearGround == true do
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        
        -- Get the workspace service
        local workspace = game:GetService("Workspace")
        
        -- Calculate the position right under the LocalPlayer's HumanoidRootPart
        local targetPosition = humanoidRootPart.Position - Vector3.new(0, 5, 0)  -- Adjust -5 to control how far under the player
        
        -- Create the table with the new MousePos as the position right under the player
        local ohTable1 = {
            ["MousePos"] = targetPosition
        }
        
        -- Fire the event with the new position
        workspace.Characters.Survivors.ShadowBlaze2814.Spear.Throw:FireServer(ohTable1)
         
        wait(0.001)
    end
end



sections.Section2:AddToggle({
    text = "Spear ground",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpearGround  = v
        SpearGround()
    end
})









_G.TpSpecific = true

function TpSpecific()
    while _G.TpSpecific == true do
-- Function to teleport the local player to a target player named "imtheboss31" with an offset of 10 studs on the Y-axis
local Players = game:GetService("Players")

-- Check if the player exists
local targetPlayer = Players:FindFirstChild("imtheboss31")
local localPlayer = Players.LocalPlayer

if targetPlayer and localPlayer then
    -- Ensure both players have a character
    local targetCharacter = targetPlayer.Character
    local localCharacter = localPlayer.Character

    if targetCharacter and localCharacter then
        -- Get the target's primary part (e.g., HumanoidRootPart)
        local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
        local localRoot = localCharacter:FindFirstChild("HumanoidRootPart")

        if targetRoot and localRoot then
            -- Teleport the local player to the target player's position with a Y-axis offset
            localRoot.CFrame = targetRoot.CFrame + Vector3.new(0, 10, 0)
        end
    end
end
  
        wait(0.01)
    end
end



sections.Section2:AddToggle({
    text = "Tp specific",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpSpecific = v
        TpSpecific()
    end
})








sections.Section2:AddSeparator({
    enabled = true,
    text = "Misc"
})




sections.Section2:AddButton({
    enabled = true,
    text = "Inf yield",
    flag = "Button_1",
    tooltip = "inf yield",
    confirm = true,
    risky = false,
    callback = function()     



loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/main/latest.lua'))()
    end
})



sections.Section2:AddButton({
    enabled = true,
    text = "Hydroxide",
    flag = "Button_1",
    tooltip = "",
    confirm = true,
    risky = false,
    callback = function()     

        local owner = "Upbolt"
        local branch = "revision"
        
        local function webImport(file)
            return loadstring(game:HttpGetAsync(("https://raw.githubusercontent.com/%s/Hydroxide/%s/%s.lua"):format(owner, branch, file)), file .. '.lua')()
        end
        
        webImport("init")
        webImport("ui/main")
            end
})



sections.Section2:AddButton({
    enabled = true,
    text = "Dex",
    flag = "Button_1",
    tooltip = "inf yield",
    confirm = true,
    risky = false,
    callback = function()     
loadstring(game:HttpGet("https://raw.githubusercontent.com/HummingBird8/HummingRn/main/OptimizedDexForSolara.lua"))()
            end
        
})


sections.Section2:AddSeparator({
    enabled = true,
    text = "Aim"
})







-- Unique Aimbot table name to avoid conflicts with other scripts
getgenv().Aimbot = {
    Status = true,
    Keybind  = 'Z', -- Changed keybind to Z
    Hitpart = 'Head', -- Changed target to Head
    ['Prediction'] = {
        X = 0, 
        Y = 0, 
    },
    Toggle = false, -- Added toggle state
}

-- Prevent overwriting the script when re-executed
if getgenv().AimbotRan then
    return
else
    getgenv().AimbotRan = true
end

-- Services
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local Players = game:GetService('Players')

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local TargetModel = nil -- Our target model

-- Modify the GetClosestModel function to exclude the LocalPlayer's character
local GetClosestModel = function()
    local ClosestDistance, ClosestModel = math.huge, nil
    local ScreenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    -- Loop through all Zombies in the workspace
    for _, Model in pairs(Workspace.Characters.Zombies:GetChildren()) do
        if Model:FindFirstChild('Head') then -- Ensure Head exists
            -- Exclude the LocalPlayer's character
            if Model == LocalPlayer.Character then
                continue
            end

            local Root, OnScreen = Camera:WorldToScreenPoint(Model.Head.Position)
            if not OnScreen then
                continue
            end

            local Distance = (ScreenCenter - Vector2.new(Root.X, Root.Y)).Magnitude
            if Distance < ClosestDistance then
                ClosestModel = Model
                ClosestDistance = Distance
            end
        end
    end

    -- Loop through other models in NoRay if any (to support multiple types of targets)
    for _, Model in pairs(Workspace.NoRay:GetChildren()) do
        if Model:FindFirstChild('Head') then -- Ensure Head exists
            -- Exclude the LocalPlayer's character
            if Model == LocalPlayer.Character then
                continue
            end

            local Root, OnScreen = Camera:WorldToScreenPoint(Model.Head.Position)
            if not OnScreen then
                continue
            end

            local Distance = (ScreenCenter - Vector2.new(Root.X, Root.Y)).Magnitude
            if Distance < ClosestDistance then
                ClosestModel = Model
                ClosestDistance = Distance
            end
        end
    end

    return ClosestModel
end

-- Add toggle for Zombies Aimbot
sections.Section2:AddToggle({
    text = "Zombies Aimbot (Z)", 
    flag = "Toggle_1",
    callback = function(v)
        Aimbot.Toggle = v -- Update toggle state
    end
})

-- Start aiming when Z is pressed
Mouse.KeyDown:Connect(function(key)
    if key == Aimbot.Keybind:lower() and Aimbot.Toggle then
        TargetModel = GetClosestModel()
    end
end)

-- Stop aiming when Z is released
Mouse.KeyUp:Connect(function(key)
    if key == Aimbot.Keybind:lower() and Aimbot.Toggle then
        TargetModel = nil
    end
end)

-- Update camera position to aim at target
RunService.RenderStepped:Connect(function()
    if not TargetModel then
        return
    end
    if not Aimbot.Status then
        return
    end
    local Hitpart = TargetModel:FindFirstChild(Aimbot.Hitpart)
    if not Hitpart then
        return
    end
    Camera.CFrame = CFrame.new(Camera.CFrame.Position, Hitpart.Position + Hitpart.Velocity * Vector3.new(Aimbot.Prediction.X, Aimbot.Prediction.Y, Aimbot.Prediction.X))
end)




-- Unique Aimbot table name to avoid conflicts with other scripts
getgenv().Aimbot_V2 = {
    Status = true,
    Keybind  = 'Z', -- Changed keybind to Z
    Hitpart = 'Head', -- Changed target to Head
    ['Prediction'] = {
        X = 0, 
        Y = 0, 
    },
    Toggle = false, -- Added toggle state
}

-- Prevent overwriting the script when re-executed
if getgenv().AimbotRan_V2 then
    return
else
    getgenv().AimbotRan_V2 = true
end

-- Existing script functionality remains the same
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local Players = game:GetService('Players')  -- Using game:GetService for Players

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local TargetModel = nil -- Our target model

-- Modify the GetClosestModel function to exclude the LocalPlayer's character
local GetClosestModel = function()
    local ClosestDistance, ClosestModel = math.huge, nil
    local ScreenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    -- Loop through all characters but exclude the LocalPlayer's character
    for _, Model in pairs(Workspace.Characters.Survivors:GetChildren()) do
        -- Ensure the model has a Humanoid, Head, and Health > 0
        if Model:FindFirstChild('Head') and Model:FindFirstChild('Humanoid') and Model.Humanoid.Health > 0 then
            -- Check if this is not the LocalPlayer's character
            if Model == LocalPlayer.Character then
                continue -- Skip the LocalPlayer's character
            end

            local Root, OnScreen = Camera:WorldToScreenPoint(Model.Head.Position)
            if not OnScreen then
                continue
            end

            local Distance = (ScreenCenter - Vector2.new(Root.X, Root.Y)).Magnitude
            if Distance < ClosestDistance then
                ClosestModel = Model
                ClosestDistance = Distance
            end
        end
    end

    return ClosestModel
end

sections.Section2:AddToggle({
    text = "Survivor aimbot (Z)", 
    flag = "Toggle_1",
    callback = function(v)
        Aimbot_V2.Toggle = v -- Update toggle state
    end
})

Mouse.KeyDown:Connect(function(key) -- Start aiming when Z is pressed
    if key == Aimbot_V2.Keybind:lower() and Aimbot_V2.Toggle then
        TargetModel = GetClosestModel()
    end
end)

Mouse.KeyUp:Connect(function(key) -- Stop aiming when Z is released
    if key == Aimbot_V2.Keybind:lower() and Aimbot_V2.Toggle then
        TargetModel = nil
    end
end)

RunService.RenderStepped:Connect(function()
    if not TargetModel then
        return
    end
    if not Aimbot_V2.Status then
        return
    end
    -- Check if current target's health is 0 and update target
    if TargetModel:FindFirstChild('Humanoid') and TargetModel.Humanoid.Health <= 0 then
        -- Lock onto the next closest model
        TargetModel = GetClosestModel()
        return
    end

    local Hitpart = TargetModel:FindFirstChild(Aimbot_V2.Hitpart)
    if not Hitpart then
        return
    end
    Camera.CFrame = CFrame.new(Camera.CFrame.Position, Hitpart.Position + Hitpart.Velocity * Vector3.new(Aimbot_V2.Prediction.X, Aimbot_V2.Prediction.Y, Aimbot_V2.Prediction.X))
end)





sections.Section2:AddSeparator({
    enabled = true,
    text = "Experimental"
})



_G.UnanchoredParts = true

function UnanchoredParts()
    while _G.UnanchoredParts == true do
-- Get necessary services using GetService
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Get the LocalPlayer
local player = Players.LocalPlayer

-- Wait for the character to load and ensure the HumanoidRootPart is available
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Define the teleport distance (5 studs in front of the character)
local teleportDistance = 0

-- Function to teleport all unanchored parts to 5 studs in front of a random Survivor's position
local function teleportUnanchoredParts()
    -- Get all models in workspace.Characters.Survivors
    local survivorsFolder = Workspace:WaitForChild("Characters"):WaitForChild("Survivors")
    local survivors = {}

    -- Collect all survivor models, excluding the LocalPlayer's character
    for _, model in pairs(survivorsFolder:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
            -- Exclude the LocalPlayer's character
            if model.Name ~= player.Name then
                table.insert(survivors, model)
            end
        end
    end

    -- If there are survivors available, teleport parts based on a random survivor's position
    if #survivors > 0 then
        -- Pick a random survivor
        local randomSurvivor = survivors[math.random(1, #survivors)]
        local survivorRootPart = randomSurvivor:WaitForChild("HumanoidRootPart")

        -- Loop through all parts in the Workspace, but skip parts under workspace.Characters
        for _, obj in pairs(Workspace:GetDescendants()) do
            -- Ensure the object is not inside the Characters folder, is a BasePart, and is unanchored
            if obj:IsA("BasePart") and not obj.Anchored and not obj:IsDescendantOf(Workspace.Characters) then
                -- Calculate the position 5 studs in front of the selected survivor's HumanoidRootPart
                local direction = survivorRootPart.CFrame.LookVector  -- Forward direction the survivor is facing
                local newPosition = survivorRootPart.Position + direction * teleportDistance
                
                -- Teleport the part to the new position
                obj.CFrame = CFrame.new(newPosition)
            end
        end
    else
        warn("No survivors found in the Survivors folder.")
    end
end

-- Call the function to teleport unanchored parts
teleportUnanchoredParts()
wait(0.7)

    end
end



sections.Section2:AddToggle({
    text = "Tp unanchored parts",
    flag = "Toggle_1",
    callback = function(v)
        _G.UnanchoredParts  = v
        UnanchoredParts()
    end
})



sections.Section2:AddButton({
    enabled = true,
    text = "Get items",
    flag = "Button_1",
    tooltip = "Tp's to medboxes",
    confirm = true,
    risky = false,
    callback = function()     
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        
        -- Make sure the HealthBoxes folder exists
        local healthBoxesFolder = workspace.Map:FindFirstChild("HealthBoxes")
        if not healthBoxesFolder then
            warn("No HealthBoxes folder found in workspace.Map!")
            return
        end
        
        -- Function to teleport the character to the Healthbox's Back part
        local function teleportToBack(healthbox)
            if healthbox:IsA("Model") and healthbox.Name == "Healthbox" then
                -- Find the Back part in the Healthbox model
                local backPart = healthbox:FindFirstChild("Back")
                if backPart and backPart:IsA("BasePart") then
                    -- Teleport the character to the Back part
                    character:SetPrimaryPartCFrame(CFrame.new(backPart.Position))
                else
                    warn("Healthbox model does not have a 'Back' part!")
                end
            end
        end
        
        
        local healthBoxes = workspace.Map.HealthBoxes:GetChildren()
        
        for i = 1, #healthBoxes do
            local healthPrompt = healthBoxes[i].Back.HealthPrompt
            fireproximityprompt(healthPrompt)
        end
        
        
        -- Iterate over all Healthboxes in the folder
        for _, healthbox in pairs(healthBoxesFolder:GetChildren()) do
            teleportToBack(healthbox)
            wait(0.1)  -- Wait 0.1 seconds before teleporting to the next Healthbox
        end
        


    end
})







library:SendNotification("Sync.wtf Succesfully Loaded!", 5, Color3.new(128, 0, 128))
wait(0.5)



library:SendNotification("Update logs: Added Hammer exploits", 5, Color3.new(128, 0, 128))

library:SendNotification("Update logs: Fixed and improved alot of features", 5, Color3.new(128, 0, 128))












--Window:SetOpen(true) -- Either Close Or Open Window
