-- Credits To The Original Devs @xz, @goof
getgenv().Config = {
	Invite = "Sync.wtf - Ready 2 die 0.0.4c",
	Version = "0.6",
}

getgenv().luaguardvars = {
	DiscordName = "4stud on discord",
}

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Yield1111/Ui-lib/refs/heads/main/Ui%20lib"))()

library:init() -- Initalizes Library Do Not Delete This

local Window = library.NewWindow({
	title = "Ready 2 die 0.0.4c",
	size = UDim2.new(0, 525, 0, 650)
})

local tabs = {
    Tab1 = Window:AddTab("Main"),
	Settings = library:CreateSettingsTab(Window),
}

-- 1 = Set Section Box To The Left
-- 2 = Set Section Box To The Right

local sections = {
	Section1 = tabs.Tab1:AddSection("Exploits", 1),
    Section2 = tabs.Tab1:AddSection("Farm", 2),

}


sections.Section1:AddButton({
    enabled = true,
    text = "Reset",
    flag = "Button_1",
    tooltip = "Resets u",
    confirm = true,
    risky = false,
    callback = function()     

local ohNumber1 = math.huge
local ohString2 = "RemoteDeath"

game:GetService("ReplicatedStorage").Events.SelfDamage:FireServer(ohNumber1, ohString2)
    end
})

_G.AutoReset = true

function AutoReset()
    while _G.AutoReset == true do
        local ohNumber1 = math.huge
        local ohString2 = "RemoteDeath"
        
        game:GetService("ReplicatedStorage").Events.SelfDamage:FireServer(ohNumber1, ohString2)
        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Auto reset (ticket farm)",
    flag = "Toggle_1",
    callback = function(v)
        _G.AutoReset  = v
        AutoReset()
    end
})







_G.SpamChat = true

function SpamChat()
    while _G.SpamChat == true do
        local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.882353, 0.294118, 0)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end







local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0, 0.678431, 0.054902)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.776471, 0, 0.831373)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)




local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.541176, 0.541176, 0.541176)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.890196, 0.890196, 0)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)





local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.94902, 0.560784, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)




local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end


-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(0.188235, 0.498039, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)



local ohString1 = "Invite"

-- Iterate over all players in the game
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    -- Make sure you don't invite the LocalPlayer (the player running the script)
    if player ~= game:GetService("Players").LocalPlayer then
        -- Fire the event to invite each player
        game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, player)
    end
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)

local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(1, 1, 1)
local ohString4 = "Gold"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)

local ohString1 = "Leave"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1)


local ohString1 = "Create"
local ohString2 = "4stud"
local ohColor33 = Color3.new(1, 0.615686, 0)
local ohString4 = "Exp"

game:GetService("ReplicatedStorage").Events.Party:FireServer(ohString1, ohString2, ohColor33, ohString4)
wait(0)
    end
end


sections.Section1:AddToggle({
    text = "Spam party",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamChat  = v
        library:SendNotification("Spam party", 5, Color3.new(255, 0, 0))
        SpamChat()
    end
})


_G.Snowball = true

function Snowball()
    while _G.Snowball == true do
        local function getClosestModelPosition(currentPosition)
            local closestModel = nil
            local closestDistance = math.huge  -- Start with a large number for comparison
            
            -- Iterate through all survivors in workspace.Characters.Survivors
            for _, model in pairs(game.Workspace.Characters.Survivors:GetChildren()) do
                if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
                    local modelPosition = model.HumanoidRootPart.Position
                    local distance = (modelPosition - currentPosition).Magnitude
                    
                    -- Check if this model is closer than the previous closest one
                    if distance < closestDistance then
                        closestDistance = distance
                        closestModel = model
                    end
                end
            end
            
            -- Return the position of the closest model or the original position if no model was found
            return closestModel and closestModel.HumanoidRootPart.Position or currentPosition
        end
        
        -- Original position (can be replaced with the variable you want to change)
        local ohVector31 = Vector3.new(0.4920186996459961, 0.05185193940997124, -0.869038999080658)
        
        -- Get the nearest model's position
        local closestPosition = getClosestModelPosition(ohVector31)
        
        -- Fire the event with the updated position
        game:GetService("ReplicatedStorage").Events.ThrowBall:FireServer(closestPosition)
        wait(0)
    end
end





sections.Section1:AddToggle({
    text = "Snowball auto shoot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Snowball  = v
        Snowball()
    end
})





_G.KingStreet = true

function KingStreet()
    while _G.KingStreet == true do
-- Get the Players service
local Players = game:GetService("Players")

-- Find the "wheel" part in the NoRay workspace
local workspaceNoRay = game.Workspace.NoRay
local wheelPart = workspaceNoRay:FindFirstChild("wheel")

-- Check if the "wheel" part exists
if wheelPart then
    -- Get the local player (assuming this is running on the client)
    local player = Players.LocalPlayer

    -- Teleport to the "wheel" part
    player.Character:SetPrimaryPartCFrame(wheelPart.CFrame)
    
    -- Wait for 0.5 seconds
    wait(0.5)
    
    -- Find the "wheel" parts in the truck's wheels
    local truck = game.Workspace.Map.Truck.KingstreetTruck
    local wheels = truck:WaitForChild("Wheels")

    -- Loop through all parts named "wheel" and teleport to each one
    for _, part in pairs(wheels:GetChildren()) do
        if part.Name == "wheel" then
            player.Character:SetPrimaryPartCFrame(part.CFrame)
            wait(0.5)  -- Wait for 0.5 seconds before teleporting to the next one
        end
    end
    
    -- Teleport to the truck's position after the loop
    player.Character:SetPrimaryPartCFrame(truck.CFrame)
else
    warn("No wheel part found in NoRay workspace.")
end

        wait(0.5)
    end
end





sections.Section1:AddToggle({
    text = "Auto complete Kingstreet campaign",
    flag = "Toggle_1",
    callback = function(v)
        _G.KingStreet  = v
        KingStreet()
    end
})






_G.TicketFarm = true

function enableNoclip(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

function disableNoclip(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

function TicketFarm()
    -- Get references to Workspace folders
    local workspace = game:GetService("Workspace")
    local charactersFolder = workspace:WaitForChild("Characters")
    local survivorsFolder = charactersFolder:WaitForChild("Survivors")
    local zombiesFolder = charactersFolder:WaitForChild("Zombies")

    -- Locate the player's character
    local localPlayerName = game:GetService("Players").LocalPlayer.Name
    local characterInSurvivors = survivorsFolder:FindFirstChild(localPlayerName)

    -- Wait until the player is in Survivors
    while not characterInSurvivors do
        print("Player not in survivors")
        characterInSurvivors = survivorsFolder:FindFirstChild(localPlayerName)
        wait(1)
    end

    -- Get the initial ticket count
    local initialTickets = game:GetService("Players").LocalPlayer.SETTINGS.Tickets.Value
    local previousTicketCount = initialTickets

    while _G.TicketFarm == true do
        -- Check if the player's character exists in the Survivors folder
        if not characterInSurvivors then
            -- Retry finding the character if it doesn't exist
            characterInSurvivors = survivorsFolder:FindFirstChild(localPlayerName)
            wait(0.1)
            continue
        end

        local noRayFolder = workspace:WaitForChild("NoRay") -- Find the NoRay folder
        local ticketPart = noRayFolder:FindFirstChild("Ticket") -- Try to find the part named "Ticket"

        local targetPosition

        if ticketPart then
            -- If "Ticket" is found, use its position to teleport
            targetPosition = ticketPart.Position
        else
            -- If "Ticket" is not found, teleport to the sky position (0, 1000, 0)
            targetPosition = Vector3.new(0, 1000, 0)
        end

        -- Enable noclip for the character
        enableNoclip(characterInSurvivors)

        -- Ensure the character has a HumanoidRootPart
        local humanoidRootPart = characterInSurvivors:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Set the Lerp parameters
            local startPosition = humanoidRootPart.Position
            local steps = 3 -- Number of interpolation steps
            local duration = 0.1 -- Total time to complete the teleport (in seconds)
            local stepDuration = duration / steps -- Time per step

            -- Add a BodyVelocity to set velocity to 0
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000) -- High force to stabilize
            bodyVelocity.Parent = humanoidRootPart

            -- Smooth Lerp movement
            for i = 1, steps do
                -- Calculate the interpolation progress
                local progress = i / steps
                -- Add wobble effect
                local wobbleOffset = Vector3.new(
                    math.random(-5, 5) * 0.1, -- Small random x offset
                    math.random(-5, 5) * 0.1, -- Small random y offset
                    math.random(-5, 5) * 0.1  -- Small random z offset
                )
                local wobblePosition = targetPosition + wobbleOffset

                -- Move the HumanoidRootPart incrementally
                humanoidRootPart.CFrame = CFrame.new(startPosition:Lerp(wobblePosition, progress))
                wait(stepDuration) -- Wait for the next step
            end

            -- Ensure the final position is exactly the target position
            humanoidRootPart.CFrame = CFrame.new(targetPosition)

            -- Cleanup: Remove BodyVelocity
            bodyVelocity:Destroy()
        end

        wait(0.1) -- Add slight delay for smoother wobbling
    end

    -- Once TicketFarm is turned off, teleport the character to the nearest model in Survivors
    if _G.TicketFarm == false then
        -- Find the nearest model in Survivors
        local closestDistance = math.huge
        local closestModel = nil

        for _, survivor in pairs(survivorsFolder:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                local distance = (characterInSurvivors.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestModel = survivor
                end
            end
        end

        -- Teleport the character to the closest survivor
        if closestModel then
            local targetHumanoidRootPart = closestModel:FindFirstChild("HumanoidRootPart")
            if targetHumanoidRootPart then
                characterInSurvivors.HumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame
            end
        end
    end

    -- Re-enable collision for the character after farming stops
    disableNoclip(characterInSurvivors)

    -- Calculate and show the tickets gained after farming stops
    local finalTicketCount = game:GetService("Players").LocalPlayer.SETTINGS.Tickets.Value
    local ticketsGained = finalTicketCount - previousTicketCount

    -- Send notification with the results
    library:SendNotification("You gained " .. ticketsGained .. " tickets!", 5, Color3.new(0, 255, 0))
end

sections.Section2:AddToggle({
    text = "Ticket farm",
    flag = "Toggle_1",
    callback = function(v)
        _G.TicketFarm = v
        if v then
            TicketFarm()
        end
    end
})











_G.ModDetector = true

function ModDetector()
    while _G.ModDetector == true do
-- List of usernames to detect
local blacklistedNames = {
    "c4rpye", "scott1333", "sagecrisi_s", "JackLighters", "alum_i", 
    "Masterdude180", "drinkyz", "IDunhill", "Dr_Greedster", "Tekrinn", 
    "TheeOfficalOG", "ur_lucky", "Synween", "mrvriie"
}

-- Get the Players service
local players = game:GetService("Players")

-- Function to check for blacklisted players
local function checkForBlacklistedPlayers()
    for _, player in ipairs(players:GetPlayers()) do
        if table.find(blacklistedNames, player.Name) then
            -- Kick the local player if a blacklisted name is found
            players.LocalPlayer:Kick("Mod detected: " .. player.Name)
            break
        end
    end
end

-- Connect to the PlayerAdded event to check new players joining
players.PlayerAdded:Connect(function(newPlayer)
    if table.find(blacklistedNames, newPlayer.Name) then
        players.LocalPlayer:Kick("Mod detected: " .. newPlayer.Name)
    end
end)

-- Initial check for players already in the game
checkForBlacklistedPlayers()

        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Mod Detector",
    flag = "Toggle_1",
    callback = function(v)
        _G.ModDetector  = v
        ModDetector()
    end
})







_G.PunchSound = true

function PunchSound()
    while _G.PunchSound == true do
        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Punch"
local ohNumber2 = 1

game:GetService("ReplicatedStorage").Events.Survivor.SoundFire:FireServer(ohString1, ohNumber2)

local ohString1 = "Punch"
local ohNumber2 = 3

game:GetService("ReplicatedStorage").Events.Survivor.SoundFire:FireServer(ohString1, ohNumber2)

        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Punch spam sound",
    flag = "Toggle_1",
    callback = function(v)
        _G.PunchSound  = v
        PunchSound()
    end
})


_G.VoteNo = true

function VoteNo()
    while _G.VoteNo == true do
        local ohNumber1 = -1

        game:GetService("ReplicatedStorage").Events.Vote:FireServer(ohNumber1)
        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Vote No to maps",
    flag = "Toggle_1",
    callback = function(v)
        _G.VoteNo  = v
        VoteNo()
    end
})


_G.GiftTp = true







function GiftTp()
    while _G.GiftTp == true do
-- List of target names
local targetNames = {
    "Aqua Gift",
    "Common Gift",
    "Gift of Fortune",
    "Gift of Kindness",
    "Gift of Life",
    "Golden Gift",
    "Legendary Gift",
    "Rare Gift"
}

-- Function to check if the player is inside workspace.Characters.Survivors
local function isPlayerInSurvivors()
    -- Get the Players service
    local players = game:GetService("Players")
    local player = players.LocalPlayer
    
    -- Check if the player's character exists
    if not player or not player.Character then
        return false
    end

    -- Check if the player's character is inside workspace.Characters.Survivors
    return workspace.Characters:FindFirstChild("Survivors") and workspace.Characters.Survivors:FindFirstChild(player.Character.Name)
end

-- Function to check if the player owns a specific gift
local function doesPlayerOwnGift(giftName)
    local player = game:GetService("Players").LocalPlayer
    local inventory = player:FindFirstChild("INVENTORY")
    
    -- Ensure the inventory and Secondary exist
    if not inventory or not inventory:FindFirstChild("Secondary") then
        return false
    end

    -- Check if the specific gift exists in the Secondary inventory
    for _, item in pairs(inventory.Secondary:GetChildren()) do
        if item.Name == giftName then
            return true -- Player already owns this specific gift
        end
    end
    
    return false -- Gift not found in inventory
end

-- Function to teleport the player to a gift if in the correct area, and return them back
local function teleportToGift()
    -- Get the Players service
    local players = game:GetService("Players")
    local player = players.LocalPlayer

    -- Check if the player is inside workspace.Characters.Survivors
    if not isPlayerInSurvivors() then
        -- Send notification if the player is not inside Survivors
        print("Not survivor")
        return
    end

    -- Store the player's current position
    local initialPosition = player.Character.HumanoidRootPart.CFrame

    -- Flag to check if a gift was found
    local giftFound = false

    -- Iterate through each object in workspace.Map
    for _, object in pairs(workspace.Map:GetChildren()) do
        -- Check if the object is a model or part and if its name matches any of the target names
        for _, name in ipairs(targetNames) do
            if object.Name == name then
                -- Check if the player already owns this specific gift
                if doesPlayerOwnGift(name) then
                    library:SendNotification("You already own: " .. name, 5, Color3.new(255, 255, 0)) -- Yellow for owned gift
                    return -- Stop processing if the gift is owned
                end

                -- If the player does not own the gift, teleport to its location
                player.Character.HumanoidRootPart.CFrame = object.CFrame
                -- Notify that the player was teleported
                library:SendNotification("Teleported to: " .. name, 5, Color3.new(0, 255, 0)) -- Green for success
                giftFound = true

                -- Wait for a moment (if necessary) before moving the player back 1 stud
                wait(0.5)

                -- Move the player 1 stud backwards (adjusting the CFrame)
                local backPosition = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
                player.Character.HumanoidRootPart.CFrame = backPosition

                -- Simulate the jump (apply force to the Humanoid)
                local humanoid = player.Character:WaitForChild("Humanoid")
                wait(0.5) -- Wait for the jump to be initiated (adjust as necessary)

                -- Teleport the player back to their initial position
                player.Character.HumanoidRootPart.CFrame = initialPosition
                -- Notify that the player is back at their original location
                library:SendNotification("Teleported back", 5, Color3.new(0, 0, 255)) -- Blue for teleport back
                return -- Stop the loop after teleporting
            end
        end
    end

    -- If no gift was found, send a notification
    if not giftFound then
        library:SendNotification("No Gift Found", 5, Color3.new(255, 0, 0)) -- Red for error
    end
end

-- Call the function to teleport to the first gift found
teleportToGift()


        wait(1)
    end
end



sections.Section2:AddToggle({
    text = "Teleport to gifts",
    flag = "Toggle_1",
    callback = function(v)
        _G.GiftTp  = v
        GiftTp()
    end
})

sections.Section2:AddSeparator({
    enabled = true,
    text = "Kill aura"
})


_G.MeleeKillAura = true

-- Initialize variables for initial Cash and Rank values
local initialCashValue = game:GetService("Players").LocalPlayer.SETTINGS.Cash.Value
local initialRankValue = game:GetService("Players").LocalPlayer.SETTINGS.Rank.Value


-- Function to handle Melee Kill Aura
function MeleeKillAura()
    while _G.MeleeKillAura == true do
        local zombies = workspace.Characters.Zombies
        local survivors = workspace.Characters.Survivors
        local player = game:GetService("Players").LocalPlayer
        
        -- Iterate through each tool in the player's backpack
        for _, tool in pairs(player.Backpack:GetChildren()) do
            -- Check if the item is a Tool and has a 'Slash' event
            if tool:IsA("Tool") and tool:FindFirstChild("Slash") then
                -- Iterate through each zombie in workspace.Characters.Zombies
                for _, zombie in pairs(zombies:GetChildren()) do
                    -- Ensure the zombie has a Head and Humanoid
                    if zombie:FindFirstChild("Head") and zombie:FindFirstChild("Humanoid") then
                        local head = zombie.Head
                        local humanoid = zombie.Humanoid
                        
                        -- Prepare the table with necessary info for the Slash
                        local ohTable2 = {
                            ["HeadShot"] = true,
                            ["Humanoid"] = humanoid,
                            ["Combo"] = 1,
                            ["Weapon"] = tool,
                            ["NoStruggle"] = true
                        }
        
                        -- Fire the Slash event for each zombie
                        tool.Slash:FireServer(head, ohTable2)
                    end
                end
                
                -- Iterate through each survivor in workspace.Characters.Survivors
                for _, survivor in pairs(survivors:GetChildren()) do
                    -- Ensure the survivor has a Head and Humanoid
                    if survivor:FindFirstChild("Head") and survivor:FindFirstChild("Humanoid") then
                        local head = survivor.Head
                        local humanoid = survivor.Humanoid
                        
                        -- Prepare the table with necessary info for the Slash
                        local ohTable2 = {
                            ["HeadShot"] = true,
                            ["Humanoid"] = humanoid,
                            ["Combo"] = 1,
                            ["Weapon"] = tool,
                            ["NoStruggle"] = true
                        }
        
                        -- Fire the Slash event for each survivor
                        tool.Slash:FireServer(head, ohTable2)
                    end
                end
            end
        end
        
        wait(0.00001)
    end

    -- Calculate and display the results after _G.MeleeKillAura is turned off
    local finalCashValue = game:GetService("Players").LocalPlayer.SETTINGS.Cash.Value
    local finalRankValue = game:GetService("Players").LocalPlayer.SETTINGS.Rank.Value
    local cashIncrease = finalCashValue - initialCashValue
    local rankIncrease = finalRankValue - initialRankValue

    -- Show separate notifications for Cash and Rank
    library:SendNotification("Cash Earned: " .. cashIncrease, 5, Color3.new(0, 255, 0))
    library:SendNotification("Ranks Earned: " .. rankIncrease, 5, Color3.new(0, 255, 0))
end

-- Toggle for activating Melee Kill Aura
sections.Section2:AddToggle({
    text = "Melee kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.MeleeKillAura = v
        if v then
            MeleeKillAura()
        end
    end
})



_G.TpZombies = true

function TpZombies()
    -- Disable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end

    -- Get a reference to the player's character
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    if playerCharacter then
        local humanoidRootPartPlayer = playerCharacter:WaitForChild("HumanoidRootPart", 10)
        local humanoid = playerCharacter:FindFirstChild("Humanoid")

        if humanoidRootPartPlayer and humanoid then
            -- Prevent the character from falling by disabling gravity and setting PlatformStand
            humanoid.PlatformStand = true
            humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)  -- Stop velocity to prevent falling
        end
    end

    while _G.TpZombies == true do
        -- Get a reference to the Zombies folder in the workspace
        local zombiesFolder = game.Workspace.Characters.Zombies

        -- Define a fallback position in the sky
        local skyPosition = Vector3.new(0, 1000, 0)  -- You can adjust the Y value to determine how high in the sky

        -- Get the player's character
        local playerCharacter = game:GetService("Players").LocalPlayer.Character
        if playerCharacter then
            -- Get the player's HumanoidRootPart and Humanoid
            local humanoidRootPartPlayer = playerCharacter:WaitForChild("HumanoidRootPart", 10)  -- Waits for up to 10 seconds
            local humanoid = playerCharacter:FindFirstChild("Humanoid")

            if humanoidRootPartPlayer and humanoid then
                -- Temporarily set the velocity of the player's HumanoidRootPart to zero to prevent fall damage
                humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)

                -- Perform teleportation logic here
                -- Check if the Zombies folder exists and has models in it
                if zombiesFolder and #zombiesFolder:GetChildren() > 0 then
                    -- Get a random model from the Zombies folder
                    local randomZombie = zombiesFolder:GetChildren()[math.random(1, #zombiesFolder:GetChildren())]

                    -- Check if the model has a HumanoidRootPart
                    local humanoidRootPart = randomZombie:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        -- Get the position of the HumanoidRootPart and add a Y offset of 15 studs
                        local targetPosition = humanoidRootPart.Position + Vector3.new(0, -12.5, 0)

                        -- Teleport the player to the new position
                        playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))
                    else
                        warn("Random zombie model does not have a HumanoidRootPart.")
                    end
                else
                    warn("No zombies found in the Zombies folder.")

                    -- If no zombies are found, teleport the player to the sky
                    local skyPosition = Vector3.new(0, 1000, 0) -- Sky position
                    playerCharacter:SetPrimaryPartCFrame(CFrame.new(skyPosition))
                end
            else
                warn("Player does not have a valid HumanoidRootPart or Humanoid.")
            end
        else
            warn("Player's character is not fully loaded.")
        end

        wait(0.1)
    end
end

-- Function to stop teleportation, restore collisions, re-enable gravity for the player, and teleport them 20 studs in the air
function stopTpZombies()
    -- Enable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end

    -- Get the player's character
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    if playerCharacter then
        local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
        local humanoid = playerCharacter:FindFirstChild("Humanoid")

        if humanoidRootPartPlayer and humanoid then
            -- Teleport the player 20 studs in the air (along the Y-axis)
            local currentPosition = humanoidRootPartPlayer.Position
            local targetPosition = currentPosition + Vector3.new(0, 20, 0)

            -- Teleport the player to the new position
            playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))

            -- Re-enable gravity and stop PlatformStand
            humanoid.PlatformStand = false
            humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)  -- Reset velocity
        end
    end
end

sections.Section2:AddToggle({
    text = "Teleport to Zombies",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpZombies = v
        if _G.TpZombies then
            TpZombies()
        else
            stopTpZombies()
        end
    end
})





_G.TpSurvivors = true

function TpSurvivors()
    -- Disable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end

    while _G.TpSurvivors == true do
        -- Get a reference to the Survivors folder in the workspace
        local survivorsFolder = game.Workspace.Characters.Survivors

        -- Define a fallback position in the sky
        local skyPosition = Vector3.new(0, 1000, 0)  -- You can adjust the Y value to determine how high in the sky

        -- Check if the Survivors folder exists and has models in it
        if survivorsFolder and #survivorsFolder:GetChildren() > 0 then
            -- Get a random model from the Survivors folder
            local randomSurvivor = survivorsFolder:GetChildren()[math.random(1, #survivorsFolder:GetChildren())]

            -- Check if the model has a HumanoidRootPart
            local humanoidRootPart = randomSurvivor:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Get the position of the HumanoidRootPart and add a Y offset of 12.5 studs
                local targetPosition = humanoidRootPart.Position + Vector3.new(0, 12.5, 0)

                -- Get the player's character
                local playerCharacter = game:GetService("Players").LocalPlayer.Character

                -- Check if the player has a HumanoidRootPart and a Humanoid
                local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
                local humanoid = playerCharacter:FindFirstChild("Humanoid")

                if humanoidRootPartPlayer and humanoid then
                    -- Temporarily set the velocity of the player's HumanoidRootPart to zero
                    humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)

                    -- Teleport the player to the new position
                    playerCharacter:SetPrimaryPartCFrame(CFrame.new(targetPosition))
                else
                    warn("Player does not have a HumanoidRootPart or Humanoid.")
                end
            else
                warn("Random survivor model does not have a HumanoidRootPart.")
            end
        else
            warn("No survivors found in the Survivors folder.")

            -- If no survivors are found, teleport the player to the sky
            local playerCharacter = game:GetService("Players").LocalPlayer.Character
            local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
            if humanoidRootPartPlayer then
                -- Temporarily set the velocity to 0 to prevent fall damage
                humanoidRootPartPlayer.Velocity = Vector3.new(0, 0, 0)
                -- Teleport the player to the sky position
                playerCharacter:SetPrimaryPartCFrame(CFrame.new(skyPosition))
            else
                warn("Player does not have a HumanoidRootPart.")
            end
        end

        wait(0.15)
    end
end

function stopTpSurvivors()
    -- Enable collisions for all parts in workspace.Map
    local map = game.Workspace:WaitForChild("Map")
    for _, part in pairs(map:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end

    -- Teleport the player 15 studs up
    local playerCharacter = game:GetService("Players").LocalPlayer.Character
    local humanoidRootPartPlayer = playerCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPartPlayer then
        -- Get the current position and add 15 studs to the Y-coordinate
        local currentPosition = humanoidRootPartPlayer.Position
        local newPosition = currentPosition + Vector3.new(0, 15, 0)

        -- Teleport the player to the new position
        playerCharacter:SetPrimaryPartCFrame(CFrame.new(newPosition))
    else
        warn("Player does not have a HumanoidRootPart.")
    end
end

sections.Section2:AddToggle({
    text = "Teleport to Survivors",
    flag = "Toggle_1",
    callback = function(v)
        _G.TpSurvivors = v
        if _G.TpSurvivors then
            TpSurvivors()
        else
            stopTpSurvivors()
        end
    end
})




















sections.Section1:AddSeparator({
    enabled = true,
    text = "Zombie Exploits"
})

_G.SpamBlock = true

function SpamBlock()
    while _G.SpamBlock == true do
        local ohBoolean1 = true

    game:GetService("ReplicatedStorage").Events.Zombie.Block:FireServer(ohBoolean1)
local ohBoolean1 = true  
        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Spam block (Brute) Crasher/Lag",
    flag = "Toggle_1",
    callback = function(v)
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
        _G.SpamBlock  = v
        SpamBlock()
    end
})









_G.BruteKill = true

function BruteKill()
    while _G.BruteKill == true do


        wait(0.1)
    end
end



sections.Section1:AddToggle({
    text = "Kill all (Brute) BROKEN!",
    flag = "Toggle_1",
    callback = function(v)
        _G.BruteKill  = v
        BruteKill()
    end
})


_G.Elmspam = true

function Elmspam()
    while _G.Elmspam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor has health greater than 0
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to shoot at the closest survivor
local function shootAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.ElmM1:FireServer(shootPosition)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to shoot at.")
    end
end

-- Call the function to shoot at the closest survivor
shootAtClosestSurvivor()

        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "elm auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Elmspam  = v
        Elmspam()
    end
})

_G.Beespam = true

function Beespam()
    while _G.Beespam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to fire at the closest survivor
local function fireAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        local ohString1 = "Honey"  -- You can keep this string as is if needed
        game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(ohString1, shootPosition)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to fire at.")
    end
end

-- Call the function to fire at the closest survivor
fireAtClosestSurvivor()


        
        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "bee auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.Beespam  = v
        Beespam()
    end
})



_G.HiveSpam = true

function HiveSpam()
    while _G.HiveSpam == true do
        -- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

local ohString1 = "Charge"

game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(ohString1)

wait(0.01)

local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to shoot at the closest survivor
local function shootAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shotPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.Throw:FireServer(shotPosition)

        -- Optionally, print a message for debugging
        print("Shooting at: " .. closestSurvivor.Name)
    else
        print("No survivors found to shoot at.")
    end
end

-- Call the function to shoot at the closest survivor
shootAtClosestSurvivor()


        wait(0)
    end
end



sections.Section1:AddToggle({
    text = "Hive auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.HiveSpam  = v
        HiveSpam()
    end
})















_G.EdgarSpam = true

function EdgarSpam()
    while _G.EdgarSpam == true do
        local LocalPlayer = game:GetService("Players").LocalPlayer

-- Function to find the closest survivor
local function getClosestSurvivor()
    local closestSurvivor = nil
    local shortestDistance = math.huge  -- Start with a very large number as the shortest distance

    -- Loop through all survivors in workspace.Characters.Survivors
    for _, survivor in pairs(workspace.Characters.Survivors:GetChildren()) do
        -- Make sure the survivor is a valid model, has a HumanoidRootPart, and has a Humanoid
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and survivor:FindFirstChild("Humanoid") then
            local humanoid = survivor.Humanoid

            -- Check if the survivor's health is greater than 0 (alive)
            if humanoid.Health > 0 then
                -- Calculate the distance from the LocalPlayer to the survivor
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).magnitude

                -- If the survivor is closer, update the closest survivor and shortest distance
                if distance < shortestDistance then
                    closestSurvivor = survivor
                    shortestDistance = distance
                end
            end
        end
    end

    return closestSurvivor
end

-- Function to fire at the closest survivor
local function fireAtClosestSurvivor()
    -- Find the closest survivor
    local closestSurvivor = getClosestSurvivor()

    if closestSurvivor then
        -- Get the position of the closest survivor's HumanoidRootPart
        local shootPosition = closestSurvivor.HumanoidRootPart.Position

        -- Fire the remote event at the position of the closest survivor
        game:GetService("ReplicatedStorage").Events.Zombie.Tongue:FireServer({["Position"] = shootPosition}, true)

        -- Optionally, print a message for debugging
        print("Firing at: " .. closestSurvivor.Name)
    else
        print("No survivors found to fire at.")
    end
end

-- Call the function to fire at the closest survivor
fireAtClosestSurvivor()

        
        wait(0)
        
    end
end

        




sections.Section1:AddToggle({
    text = "Edgar auto shoot + aimbot",
    flag = "Toggle_1",
    callback = function(v)
        _G.EdgarSpam  = v
        EdgarSpam()
    end
})

sections.Section1:AddSeparator({
    enabled = true,
    text = "Visuals"
})

-- Function for changing FOV
local function FovChanger2()
    local player = game:GetService("Players").LocalPlayer
    local camera = game:GetService("Workspace").CurrentCamera
    
    -- Loop to constantly change the FOV while toggle is on
    while _G.FovChanger2 do
        camera.FieldOfView = 120  -- Set the desired FOV to 120
        wait(0.1)  -- Wait for 0.5 seconds before updating again
    end
end

-- Add the toggle for changing FOV
sections.Section1:AddToggle({
    text = "Fov changer",  -- Toggle name
    flag = "Toggle_1",  -- Flag for state tracking
    callback = function(v)
        -- When the toggle is turned on
        if v then
            _G.FovChanger2 = true  -- Enable FOV change loop
            FovChanger2()  -- Start the function

        else
            -- When the toggle is turned off, set FOV to 90
            _G.FovChanger2 = false  -- Stop FOV change loop
            local player = game:GetService("Players").LocalPlayer
            local camera = game:GetService("Workspace").CurrentCamera
            camera.FieldOfView = 90  -- Set the FOV to 90
        end
    end
})







_G.ForcefieldWeapon = true

function ForcefieldWeapon()
    while _G.ForcefieldWeapon == true do
-- Get the local player using GetService
local player = game:GetService("Players").LocalPlayer

-- Check if player exists
if player then
    -- Get the Backpack of the player
    local backpack = player.Backpack

    -- Loop through all tools in the player's Backpack
    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            -- Loop through all parts in the tool and change their material and color
            for _, part in ipairs(tool:GetChildren()) do
                if part:IsA("BasePart") then
                    -- Change the material to ForceField
                    part.Material = Enum.Material.ForceField
                    
                    -- Change the color to red
                    part.Color = Color3.fromRGB(255, 0, 0)  -- RGB for red
                end
            end
        end
    end
else
    warn("LocalPlayer not found.")
end


        
        wait(0.25)
    end
end



sections.Section1:AddToggle({
    text = "ForceField weapon",
    flag = "Toggle_1",
    callback = function(v)
        _G.ForcefieldWeapon  = v
        ForcefieldWeapon()
    end
})








sections.Section1:AddToggle({
    text = "Esp",
    flag = "Toggle_1",
    callback = function(v)
        --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
local ESP = loadstring(game:HttpGet("https://raw.githubusercontent.com/pAdsasd3q2/Da98123412dsxf/refs/heads/main/Esp"))();

--// Master switch
ESP.Enabled = v;

--// Enable boxes
ESP.ShowBox = true;

--// Set the box type to corner
ESP.BoxType = "Corner Box Esp";

--// Enable names
ESP.ShowName = true;

--// Enable Healhbar
ESP.ShowHealth = false;

--// Enable tracers
ESP.ShowTracer = false;

--// Enable Distance
ESP.ShowDistance = true;

ESP.Teamcheck = true;




--[[
    Enable skeletons: (currently broken)
    ESP.ShowSkeletons = true;
]]



--[[
    These are all the settings
    local ESP_SETTINGS = {
        BoxOutlineColor = Color3.new(0, 0, 0),
        BoxColor = Color3.new(1, 1, 1),
        NameColor = Color3.new(1, 1, 1),
        HealthOutlineColor = Color3.new(0, 0, 0),
        HealthHighColor = Color3.new(0, 1, 0),
        HealthLowColor = Color3.new(1, 0, 0),
        CharSize = Vector2.new(4, 6),
        Teamcheck = false,
        WallCheck = false,
        Enabled = false,
        ShowBox = false,
        BoxType = "2D",
        ShowName = false,
        ShowHealth = false,
        ShowDistance = false,
        ShowSkeletons = false,
        ShowTracer = false,
        TracerColor = Color3.new(1, 1, 1), 
        TracerThickness = 2,
        SkeletonsColor = Color3.new(1, 1, 1),
        TracerPosition = "Bottom",
    }
    ermm yep thats about it
]]



    end
})

sections.Section1:AddSeparator({
    enabled = true,
    text = "Misc"
})




sections.Section1:AddButton({
    enabled = true,
    text = "Inf yield",
    flag = "Button_1",
    tooltip = "inf yield",
    confirm = true,
    risky = false,
    callback = function()     



loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/main/latest.lua'))()
    end
})








_G.ZombieKillAura = true

function ZombieKillAura()
    while _G.ZombieKillAura == true do
        local survivorsFolder = workspace.Characters.Survivors

        -- Loop through all the models in the Survivors folder
        for _, survivor in pairs(survivorsFolder:GetChildren()) do
            -- Check if the survivor model has the necessary parts
            local humanoid = survivor:FindFirstChild("Humanoid")
            local humanoidRootPart = survivor:FindFirstChild("HumanoidRootPart")
            
            -- Only proceed if both the Humanoid and HumanoidRootPart exist
            if humanoid and humanoidRootPart then
                -- Fire the event for each survivor
                game:GetService("ReplicatedStorage").Events.Zombie.ClawAttacked:FireServer(humanoid, nil, nil, humanoidRootPart)
            end
        end
        
        wait(0.0001)
    end
end



sections.Section2:AddToggle({
    text = "Zombie kill aura",
    flag = "Toggle_1",
    callback = function(v)
        _G.ZombieKillAura  = v
        ZombieKillAura()
    end
})





library:SendNotification("Sync.wtf Succesfully Loaded!", 5, Color3.new(0, 255, 0))
wait(0.5)



library:SendNotification("Update logs: Added Auto Complete KingStreet", 5, Color3.new(0, 0, 255))

library:SendNotification("Update logs: Fixed and improved alot of features", 5, Color3.new(0, 0, 255))












--Window:SetOpen(true) -- Either Close Or Open Window
